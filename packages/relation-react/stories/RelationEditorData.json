{
  "fromPath": "README.md",
  "toPath": "files/zh-cn/github/jsdom.md",
  "fromModifiedContent": "<h1 align=\"center\">\n    <img width=\"100\" height=\"100\" src=\"logo.svg\" alt=\"\"><br>\n    jsdom\n</h1>\n\njsdom is a pure-JavaScript implementation of many web standards, notably the WHATWG [DOM](https://dom.spec.whatwg.org/) and [HTML](https://html.spec.whatwg.org/multipage/) Standards, for use with Node.js. In general, the goal of the project is to emulate enough of a subset of a web browser to be useful for testing and scraping real-world web applications.\n\nThe latest versions of jsdom require Node.js v14 or newer. (Versions of jsdom below v20 still work with previous Node.js versions, but are unsupported.)\n\n## Basic usage\n\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n\nTo use jsdom, you will primarily use the `JSDOM` constructor, which is a named export of the jsdom main module. Pass the constructor a string. You will get back a `JSDOM` object, which has a number of useful properties, notably `window`:\n\n```js\nconst dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); // \"Hello world\"\n```\n\n(Note that jsdom will parse the HTML you pass it just like a browser does, including implied `<html>`, `<head>`, and `<body>` tags.)\n\nThe resulting object is an instance of the `JSDOM` class, which contains a number of useful properties and methods besides `window`. In general, it can be used to act on the jsdom from the \"outside,\" doing things that are not possible with the normal DOM APIs. For simple cases, where you don't need any of this functionality, we recommend a coding pattern like\n\n```js\nconst { window } = new JSDOM(`...`);\n// or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n\nFull documentation on everything you can do with the `JSDOM` class is below, in the section \"`JSDOM` Object API\".\n\n## Customizing jsdom\n\nThe `JSDOM` constructor accepts a second parameter which can be used to customize your jsdom in the following ways.\n\n### Simple options\n\n```js\nconst dom = new JSDOM(``, {\n  url: \"https://example.org/\",\n  referrer: \"https://example.com/\",\n  contentType: \"text/html\",\n  includeNodeLocations: true,\n  storageQuota: 10000000\n});\n```\n\n- `url` sets the value returned by `window.location`, `document.URL`, and `document.documentURI`, and affects things like resolution of relative URLs within the document and the same-origin restrictions and referrer used while fetching subresources. It defaults to `\"about:blank\"`.\n- `referrer` just affects the value read from `document.referrer`. It defaults to no referrer (which reflects as the empty string).\n- `contentType` affects the value read from `document.contentType`, as well as how the document is parsed: as HTML or as XML. Values that are not a [HTML MIME type](https://mimesniff.spec.whatwg.org/#html-mime-type) or an [XML MIME type](https://mimesniff.spec.whatwg.org/#xml-mime-type) will throw. It defaults to `\"text/html\"`. If a `charset` parameter is present, it can affect [binary data processing](#encoding-sniffing).\n- `includeNodeLocations` preserves the location info produced by the HTML parser, allowing you to retrieve it with the `nodeLocation()` method (described below). It also ensures that line numbers reported in exception stack traces for code running inside `<script>` elements are correct. It defaults to `false` to give the best performance, and cannot be used with an XML content type since our XML parser does not support location info.\n- `storageQuota` is the maximum size in code units for the separate storage areas used by `localStorage` and `sessionStorage`. Attempts to store data larger than this limit will cause a `DOMException` to be thrown. By default, it is set to 5,000,000 code units per origin, as inspired by the HTML specification.\n\nNote that both `url` and `referrer` are canonicalized before they're used, so e.g. if you pass in `\"https:example.com\"`, jsdom will interpret that as if you had given `\"https://example.com/\"`. If you pass an unparseable URL, the call will throw. (URLs are parsed and serialized according to the [URL Standard](https://url.spec.whatwg.org/).)\n\n### Executing scripts\n\njsdom's most powerful ability is that it can execute scripts inside the jsdom. These scripts can modify the content of the page and access all the web platform APIs jsdom implements.\n\nHowever, this is also highly dangerous when dealing with untrusted content. The jsdom sandbox is not foolproof, and code running inside the DOM's `<script>`s can, if it tries hard enough, get access to the Node.js environment, and thus to your machine. As such, the ability to execute scripts embedded in the HTML is disabled by default:\n\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`);\n\n// The script will not be executed, by default:\ndom.window.document.body.children.length === 1;\n```\n\nTo enable executing scripts inside the page, you can use the `runScripts: \"dangerously\"` option:\n\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`, { runScripts: \"dangerously\" });\n\n// The script will be executed and modify the DOM:\ndom.window.document.body.children.length === 2;\n```\n\nAgain we emphasize to only use this when feeding jsdom code you know is safe. If you use it on arbitrary user-supplied code, or code from the Internet, you are effectively running untrusted Node.js code, and your machine could be compromised.\n\nIf you want to execute _external_ scripts, included via `<script src=\"\">`, you'll also need to ensure that they load them. To do this, add the option `resources: \"usable\"` [as described below](#loading-subresources). (You'll likely also want to set the `url` option, for the reasons discussed there.)\n\nEvent handler attributes, like `<div onclick=\"\">`, are also governed by this setting; they will not function unless `runScripts` is set to `\"dangerously\"`. (However, event handler _properties_, like `div.onclick = ...`, will function regardless of `runScripts`.)\n\nIf you are simply trying to execute script \"from the outside\", instead of letting `<script>` elements and event handlers attributes run \"from the inside\", you can use the `runScripts: \"outside-only\"` option, which enables fresh copies of all the JavaScript spec-provided globals to be installed on `window`. This includes things like `window.Array`, `window.Promise`, etc. It also, notably, includes `window.eval`, which allows running scripts, but with the jsdom `window` as the global:\n\n```js\nconst { window } = new JSDOM(``, { runScripts: \"outside-only\" });\n\nwindow.eval(`document.body.innerHTML = \"<p>Hello, world!</p>\";`);\nwindow.document.body.children.length === 1;\n```\n\nThis is turned off by default for performance reasons, but is safe to enable.\n\n(Note that in the default configuration, without setting `runScripts`, the values of `window.Array`, `window.eval`, etc. will be the same as those provided by the outer Node.js environment. That is, `window.eval === eval` will hold, so `window.eval` will not run scripts in a useful way.)\n\nWe strongly advise against trying to \"execute scripts\" by mashing together the jsdom and Node global environments (e.g. by doing `global.window = dom.window`), and then executing scripts or test code inside the Node global environment. Instead, you should treat jsdom like you would a browser, and run all scripts and tests that need access to a DOM inside the jsdom environment, using `window.eval` or `runScripts: \"dangerously\"`. This might require, for example, creating a browserify bundle to execute as a `<script>` element—just like you would in a browser.\n\nFinally, for advanced use cases you can use the `dom.getInternalVMContext()` method, documented below.\n\n### Pretending to be a visual browser\n\njsdom does not have the capability to render visual content, and will act like a headless browser by default. It provides hints to web pages through APIs such as `document.hidden` that their content is not visible.\n\nWhen the `pretendToBeVisual` option is set to `true`, jsdom will pretend that it is rendering and displaying content. It does this by:\n\n* Changing `document.hidden` to return `false` instead of `true`\n* Changing `document.visibilityState` to return `\"visible\"` instead of `\"prerender\"`\n* Enabling `window.requestAnimationFrame()` and `window.cancelAnimationFrame()` methods, which otherwise do not exist\n\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp => {\n  console.log(timestamp > 0);\n});\n```\n\nNote that jsdom still [does not do any layout or rendering](#unimplemented-parts-of-the-web-platform), so this is really just about _pretending_ to be visual, not about implementing the parts of the platform a real, visual web browser would implement.\n\n### Loading subresources\n\n#### Basic options\n\nBy default, jsdom will not load any subresources such as scripts, stylesheets, images, or iframes. If you'd like jsdom to load such resources, you can pass the `resources: \"usable\"` option, which will load all usable resources. Those are:\n\n* Frames and iframes, via `<frame>` and `<iframe>`\n* Stylesheets, via `<link rel=\"stylesheet\">`\n* Scripts, via `<script>`, but only if `runScripts: \"dangerously\"` is also set\n* Images, via `<img>`, but only if the `canvas` npm package is also installed (see \"[Canvas Support](#canvas-support)\" below)\n\nWhen attempting to load resources, recall that the default value for the `url` option is `\"about:blank\"`, which means that any resources included via relative URLs will fail to load. (The result of trying to parse the URL `/something` against the URL `about:blank` is an error.) So, you'll likely want to set a non-default value for the `url` option in those cases, or use one of the [convenience APIs](#convenience-apis) that do so automatically.\n\n#### Advanced configuration\n\nTo more fully customize jsdom's resource-loading behavior, you can pass an instance of the `ResourceLoader` class as the `resources` option value:\n\n```js\nconst resourceLoader = new jsdom.ResourceLoader({\n  proxy: \"http://127.0.0.1:9001\",\n  strictSSL: false,\n  userAgent: \"Mellblomenator/9000\",\n});\nconst dom = new JSDOM(``, { resources: resourceLoader });\n```\n\nThe three options to the `ResourceLoader` constructor are:\n\n- `proxy` is the address of an HTTP proxy to be used.\n- `strictSSL` can be set to false to disable the requirement that SSL certificates be valid.\n- `userAgent` affects the `User-Agent` header sent, and thus the resulting value for `navigator.userAgent`. It defaults to <code>\\`Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/${jsdomVersion}\\`</code>.\n\nYou can further customize resource fetching by subclassing `ResourceLoader` and overriding the `fetch()` method. For example, here is a version that overrides the response provided for a specific URL:\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    // Override the contents of this script to do something unusual.\n    if (url === \"https://example.com/some-specific-script.js\") {\n      return Promise.resolve(Buffer.from(\"window.someGlobal = 5;\"));\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\njsdom will call your custom resource loader's `fetch()` method whenever it encounters a \"usable\" resource, per the above section. The method takes a URL string, as well as a few options which you should pass through unmodified if calling `super.fetch()`. It must return a promise for a Node.js `Buffer` object, or return `null` if the resource is intentionally not to be loaded. In general, most cases will want to delegate to `super.fetch()`, as shown.\n\nOne of the options you will receive in `fetch()` will be the element (if applicable) that is fetching a resource.\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    if (options.element) {\n      console.log(`Element ${options.element.localName} is requesting the url ${url}`);\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\n### Virtual consoles\n\nLike web browsers, jsdom has the concept of a \"console\". This records both information directly sent from the page, via scripts executing inside the document, as well as information from the jsdom implementation itself. We call the user-controllable console a \"virtual console\", to distinguish it from the Node.js `console` API and from the inside-the-page `window.console` API.\n\nBy default, the `JSDOM` constructor will return an instance with a virtual console that forwards all its output to the Node.js console. To create your own virtual console and pass it to jsdom, you can override this default by doing\n\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n\nCode like this will create a virtual console with no behavior. You can give it behavior by adding event listeners for all the possible console methods:\n\n```js\nvirtualConsole.on(\"error\", () => { ... });\nvirtualConsole.on(\"warn\", () => { ... });\nvirtualConsole.on(\"info\", () => { ... });\nvirtualConsole.on(\"dir\", () => { ... });\n// ... etc. See https://console.spec.whatwg.org/#logging\n```\n\n(Note that it is probably best to set up these event listeners *before* calling `new JSDOM()`, since errors or console-invoking script might occur during parsing.)\n\nIf you simply want to redirect the virtual console output to another console, like the default Node.js one, you can do\n\n```js\nvirtualConsole.sendTo(console);\n```\n\nThere is also a special event, `\"jsdomError\"`, which will fire with error objects to report errors from jsdom itself. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by `console.error`. So far, the following errors are output this way:\n\n- Errors loading or parsing subresources (scripts, stylesheets, frames, and iframes)\n- Script execution errors that are not handled by a window `onerror` event handler that returns `true` or calls `event.preventDefault()`\n- Not-implemented errors resulting from calls to methods, like `window.alert`, which jsdom does not implement, but installs anyway for web compatibility\n\nIf you're using `sendTo(c)` to send errors to `c`, by default it will call `c.error(errorStack[, errorDetail])` with information from `\"jsdomError\"` events. If you'd prefer to maintain a strict one-to-one mapping of events to method calls, and perhaps handle `\"jsdomError\"`s yourself, then you can do\n\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n\n### Cookie jars\n\nLike web browsers, jsdom has the concept of a cookie jar, storing HTTP cookies. Cookies that have a URL on the same domain as the document, and are not marked HTTP-only, are accessible via the `document.cookie` API. Additionally, all cookies in the cookie jar will impact the fetching of subresources.\n\nBy default, the `JSDOM` constructor will return an instance with an empty cookie jar. To create your own cookie jar and pass it to jsdom, you can override this default by doing\n\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n\nThis is mostly useful if you want to share the same cookie jar among multiple jsdoms, or prime the cookie jar with certain values ahead of time.\n\nCookie jars are provided by the [tough-cookie](https://www.npmjs.com/package/tough-cookie) package. The `jsdom.CookieJar` constructor is a subclass of the tough-cookie cookie jar which by default sets the `looseMode: true` option, since that [matches better how browsers behave](https://github.com/whatwg/html/issues/804). If you want to use tough-cookie's utilities and classes yourself, you can use the `jsdom.toughCookie` module export to get access to the tough-cookie module instance packaged with jsdom.\n\n### Intervening before parsing\n\njsdom allows you to intervene in the creation of a jsdom very early: after the `Window` and `Document` objects are created, but before any HTML is parsed to populate the document with nodes:\n\n```js\nconst dom = new JSDOM(`<p>Hello</p>`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () => { /* ... */ };\n  }\n});\n```\n\nThis is especially useful if you are wanting to modify the environment in some way, for example adding shims for web platform APIs jsdom does not support.\n\n## `JSDOM` object API\n\nOnce you have constructed a `JSDOM` object, it will have the following useful capabilities:\n\n### Properties\n\nThe property `window` retrieves the `Window` object that was created for you.\n\nThe properties `virtualConsole` and `cookieJar` reflect the options you pass in, or the defaults created for you if nothing was passed in for those options.\n\n### Serializing the document with `serialize()`\n\nThe `serialize()` method will return the [HTML serialization](https://html.spec.whatwg.org/#html-fragment-serialisation-algorithm) of the document, including the doctype:\n\n```js\nconst dom = new JSDOM(`<!DOCTYPE html>hello`);\n\ndom.serialize() === \"<!DOCTYPE html><html><head></head><body>hello</body></html>\";\n\n// Contrast with:\ndom.window.document.documentElement.outerHTML === \"<html><head></head><body>hello</body></html>\";\n```\n\n### Getting the source location of a node with `nodeLocation(node)`\n\nThe `nodeLocation()` method will find where a DOM node is within the source document, returning the [parse5 location info](https://www.npmjs.com/package/parse5#options-locationinfo) for the node:\n\n```js\nconst dom = new JSDOM(\n  `<p>Hello\n    <img src=\"foo.jpg\">\n  </p>`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; // implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   // null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      // { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); // { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    // { startOffset: 13, endOffset: 32 }\n```\n\nNote that this feature only works if you have set the `includeNodeLocations` option; node locations are off by default for performance reasons.\n\n### Interfacing with the Node.js `vm` module using `getInternalVMContext()`\n\nThe built-in [`vm`](https://nodejs.org/api/vm.html) module of Node.js is what underpins jsdom's script-running magic. Some advanced use cases, like pre-compiling a script and then running it multiple times, benefit from using the `vm` module directly with a jsdom-created `Window`.\n\nTo get access to the [contextified global object](https://nodejs.org/api/vm.html#vm_what_does_it_mean_to_contextify_an_object), suitable for use with the `vm` APIs, you can use the `getInternalVMContext()` method:\n\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst script = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\nconst vmContext = dom.getInternalVMContext();\n\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\n\nconsole.assert(dom.window.ran === 3);\n```\n\nThis is somewhat-advanced functionality, and we advise sticking to normal DOM APIs (such as `window.eval()` or `document.createElement(\"script\")`) unless you have very specific needs.\n\nNote that this method will throw an exception if the `JSDOM` instance was created without `runScripts` set, or if you are [using jsdom in a web browser](#running-jsdom-inside-a-web-browser).\n\n### Reconfiguring the jsdom with `reconfigure(settings)`\n\nThe `top` property on `window` is marked `[Unforgeable]` in the spec, meaning it is a non-configurable own property and thus cannot be overridden or shadowed by normal code running inside the jsdom, even using `Object.defineProperty`.\n\nSimilarly, at present jsdom does not handle navigation (such as setting `window.location.href = \"https://example.com/\"`); doing so will cause the virtual console to emit a `\"jsdomError\"` explaining that this feature is not implemented, and nothing will change: there will be no new `Window` or `Document` object, and the existing `window`'s `location` object will still have all the same property values.\n\nHowever, if you're acting from outside the window, e.g. in some test framework that creates jsdoms, you can override one or both of these using the special `reconfigure()` method:\n\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({ windowTop: myFakeTopForTesting, url: \"https://example.com/\" });\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https://example.com/\";\n```\n\nNote that changing the jsdom's URL will impact all APIs that return the current document URL, such as `window.location`, `document.URL`, and `document.documentURI`, as well as the resolution of relative URLs within the document, and the same-origin checks and referrer used while fetching subresources. It will not, however, perform navigation to the contents of that URL; the contents of the DOM will remain unchanged, and no new instances of `Window`, `Document`, etc. will be created.\n\n## Convenience APIs\n\n### `fromURL()`\n\nIn addition to the `JSDOM` constructor itself, jsdom provides a promise-returning factory method for constructing a jsdom from a URL:\n\n```js\nJSDOM.fromURL(\"https://example.com/\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the URL is valid and the request is successful. Any redirects will be followed to their ultimate destination.\n\nThe options provided to `fromURL()` are similar to those provided to the `JSDOM` constructor, with the following additional restrictions and consequences:\n\n- The `url` and `contentType` options cannot be provided.\n- The `referrer` option is used as the HTTP `Referer` request header of the initial request.\n- The `resources` option also affects the initial request; this is useful if you want to, for example, configure a proxy (see above).\n- The resulting jsdom's URL, content type, and referrer are determined from the response.\n- Any cookies set via HTTP `Set-Cookie` response headers are stored in the jsdom's cookie jar. Similarly, any cookies already in a supplied cookie jar are sent as HTTP `Cookie` request headers.\n\n### `fromFile()`\n\nSimilar to `fromURL()`, jsdom also provides a `fromFile()` factory method for constructing a jsdom from a filename:\n\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the given file can be opened. As usual in Node.js APIs, the filename is given relative to the current working directory.\n\nThe options provided to `fromFile()` are similar to those provided to the `JSDOM` constructor, with the following additional defaults:\n\n- The `url` option will default to a file URL corresponding to the given filename, instead of to `\"about:blank\"`.\n- The `contentType` option will default to `\"application/xhtml+xml\"` if the given filename ends in `.xht`, `.xhtml`, or `.xml`; otherwise it will continue to default to `\"text/html\"`.\n\n### `fragment()`\n\nFor the very simplest of cases, you might not need a whole `JSDOM` instance with all its associated power. You might not even need a `Window` or `Document`! Instead, you just need to parse some HTML, and get a DOM object you can manipulate. For that, we have `fragment()`, which creates a `DocumentFragment` from a given string:\n\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p><p><strong>Hi!</strong>`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent === \"Hi!\";\n// etc.\n```\n\nHere `frag` is a [`DocumentFragment`](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) instance, whose contents are created by parsing the provided string. The parsing is done using a `<template>` element, so you can include any element there (including ones with weird parsing rules like `<td>`). It's also important to note that the resulting `DocumentFragment` will not have [an associated browsing context](https://html.spec.whatwg.org/multipage/#concept-document-bc): that is, elements' `ownerDocument` will have a null `defaultView` property, resources will not load, etc.\n\nAll invocations of the `fragment()` factory result in `DocumentFragment`s that share the same template owner `Document`. This allows many calls to `fragment()` with no extra overhead. But it also means that calls to `fragment()` cannot be customized with any options.\n\nNote that serialization is not as easy with `DocumentFragment`s as it is with full `JSDOM` objects. If you need to serialize your DOM, you should probably use the `JSDOM` constructor more directly. But for the special case of a fragment containing a single element, it's pretty easy to do through normal means:\n\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p>`);\nconsole.log(frag.firstChild.outerHTML); // logs \"<p>Hello</p>\"\n```\n\n## Other noteworthy features\n\n### Canvas support\n\njsdom includes support for using the [`canvas`](https://www.npmjs.com/package/canvas) package to extend any `<canvas>` elements with the canvas API. To make this work, you need to include `canvas` as a dependency in your project, as a peer of `jsdom`. If jsdom can find the `canvas` package, it will use it, but if it's not present, then `<canvas>` elements will behave like `<div>`s. Since jsdom v13, version 2.x of `canvas` is required; version 1.x is no longer supported.\n\n### Encoding sniffing\n\nIn addition to supplying a string, the `JSDOM` constructor can also be supplied binary data, in the form of a Node.js [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html) or a standard JavaScript binary data type like `ArrayBuffer`, `Uint8Array`, `DataView`, etc. When this is done, jsdom will [sniff the encoding](https://html.spec.whatwg.org/multipage/syntax.html#encoding-sniffing-algorithm) from the supplied bytes, scanning for `<meta charset>` tags just like a browser does.\n\nIf the supplied `contentType` option contains a `charset` parameter, that encoding will override the sniffed encoding—unless a UTF-8 or UTF-16 BOM is present, in which case those take precedence. (Again, this is just like a browser.)\n\nThis encoding sniffing also applies to `JSDOM.fromFile()` and `JSDOM.fromURL()`. In the latter case, any `Content-Type` headers sent with the response will take priority, in the same fashion as the constructor's `contentType` option.\n\nNote that in many cases supplying bytes in this fashion can be better than supplying a string. For example, if you attempt to use Node.js's `buffer.toString(\"utf-8\")` API, Node.js will not strip any leading BOMs. If you then give this string to jsdom, it will interpret it verbatim, leaving the BOM intact. But jsdom's binary data decoding code will strip leading BOMs, just like a browser; in such cases, supplying `buffer` directly will give the desired result.\n\n### Closing down a jsdom\n\nTimers in the jsdom (set by `window.setTimeout()` or `window.setInterval()`) will, by definition, execute code in the future in the context of the window. Since there is no way to execute code in the future without keeping the process alive, outstanding jsdom timers will keep your Node.js process alive. Similarly, since there is no way to execute code in the context of an object without keeping that object alive, outstanding jsdom timers will prevent garbage collection of the window on which they are scheduled.\n\nIf you want to be sure to shut down a jsdom window, use `window.close()`, which will terminate all running timers (and also remove any event listeners on the window and document).\n\n### Running jsdom inside a web browser\n\njsdom has some support for being run inside a web browser, using [browserify](https://browserify.org/). That is, inside a web browser, you can use a browserified jsdom to create an entirely self-contained set of plain JavaScript objects which look and act much like the browser's existing DOM objects, while being entirely independent of them. \"Virtual DOM\", indeed!\n\njsdom's primary target is still Node.js, and so we use language features that are only present in recent Node.js versions. Thus, older browsers will likely not work. (Even transpilation will not help: we use `Proxy`s extensively throughout the jsdom codebase.)\n\nNotably, jsdom works well inside a web worker. The original contributor, [@lawnsea](https://github.com/lawnsea/), who made this possible, has [published a paper](https://pdfs.semanticscholar.org/47f0/6bb6607a975500a30e9e52d7c9fbc0034e27.pdf) about his project which uses this capability.\n\nNot everything works perfectly when running jsdom inside a web browser. Sometimes that is because of fundamental limitations (such as not having filesystem access), but sometimes it is simply because we haven't spent enough time making the appropriate small tweaks. Bug reports are certainly welcome.\n\n### Debugging the DOM using Chrome DevTools\n\nIn Node.js you can debug programs using Chrome DevTools. See the [official documentation](https://nodejs.org/en/docs/inspector/) for how to get started.\n\nBy default jsdom elements are formatted as plain old JS objects in the console. To make it easier to debug, you can use [jsdom-devtools-formatter](https://github.com/jsdom/jsdom-devtools-formatter), which lets you inspect them like real DOM elements.\n\n## Caveats\n\n### Asynchronous script loading\n\nPeople often have trouble with asynchronous script loading when using jsdom. Many pages load scripts asynchronously, but there is no way to tell when they're done doing so, and thus when it's a good time to run your code and inspect the resulting DOM structure. This is a fundamental limitation; we cannot predict what scripts on the web page will do, and so cannot tell you when they are done loading more scripts.\n\nThis can be worked around in a few ways. The best way, if you control the page in question, is to use whatever mechanisms are given by the script loader to detect when loading is done. For example, if you're using a module loader like RequireJS, the code could look like:\n\n```js\n// On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () => {\n  console.log(\"ready to roll!\");\n};\n```\n\n```html\n<!-- Inside the HTML you supply to jsdom -->\n<script>\nrequirejs([\"entry-module\"], () => {\n  window.onModulesLoaded();\n});\n</script>\n```\n\nIf you do not control the page, you could try workarounds such as polling for the presence of a specific element.\n\nFor more details, see the discussion in [#640](https://github.com/jsdom/jsdom/issues/640), especially [@matthewkastor](https://github.com/matthewkastor)'s [insightful comment](https://github.com/jsdom/jsdom/issues/640#issuecomment-22216965).\n\n### Unimplemented parts of the web platform\n\nAlthough we enjoy adding new features to jsdom and keeping it up to date with the latest web specs, it has many missing APIs. Please feel free to file an issue for anything missing, but we're a small and busy team, so a pull request might work even better.\n\nSome features of jsdom are provided by our dependencies. Notable documentation in that regard includes the list of [supported CSS selectors](https://github.com/dperini/nwsapi/wiki/CSS-supported-selectors) for our CSS selector engine, [`nwsapi`](https://github.com/dperini/nwsapi).\n\nBeyond just features that we haven't gotten to yet, there are two major features that are currently outside the scope of jsdom. These are:\n\n- **Navigation**: the ability to change the global object, and all other objects, when clicking a link or assigning `location.href` or similar.\n- **Layout**: the ability to calculate where elements will be visually laid out as a result of CSS, which impacts methods like `getBoundingClientRects()` or properties like `offsetTop`.\n\nCurrently jsdom has dummy behaviors for some aspects of these features, such as sending a \"not implemented\" `\"jsdomError\"` to the virtual console for navigation, or returning zeros for many layout-related properties. Often you can work around these limitations in your code, e.g. by creating new `JSDOM` instances for each page you \"navigate\" to during a crawl, or using `Object.defineProperty()` to change what various layout-related getters and methods return.\n\nNote that other tools in the same space, such as PhantomJS, do support these features. On the wiki, we have a more complete writeup about [jsdom vs. PhantomJS](https://github.com/jsdom/jsdom/wiki/jsdom-vs.-PhantomJS).\n\n## Supporting jsdom\n\njsdom is a community-driven project maintained by a team of [volunteers](https://github.com/orgs/jsdom/people). You could support jsdom by:\n\n- [Getting professional support for jsdom](https://tidelift.com/subscription/pkg/npm-jsdom?utm_source=npm-jsdom&utm_medium=referral&utm_campaign=readme) as part of a Tidelift subscription. Tidelift helps making open source sustainable for us while giving teams assurances for maintenance, licensing, and security.\n- [Contributing](https://github.com/jsdom/jsdom/blob/master/Contributing.md) directly to the project.\n\n## Getting help\n\nIf you need help with jsdom, please feel free to use any of the following venues:\n\n- The [mailing list](https://groups.google.com/group/jsdom) (best for \"how do I\" questions)\n- The [issue tracker](https://github.com/jsdom/jsdom/issues) (best for bug reports)\n- The Matrix room: [#jsdom:matrix.org](https://matrix.to/#/#jsdom:matrix.org)\n",
  "toModifiedContent": "---\ntitle: jsdom 中文文档\n---\n\n<h1 align=\"center\">\n    <img width=\"100\" height=\"100\" src=\"https://github.com/jsdom/jsdom/raw/master/logo.svg\" alt=\"\"><br>\n    jsdom\n</h1>\n\njsdom 是一个纯粹由 JavaScript 实现的一系列 Web 标准，特别是 WHATWG 组织制定的 [DOM](https://dom.spec.whatwg.org/) 和 [HTML](https://html.spec.whatwg.org/multipage/) 标准，用于在 Node.js 中使用。大体上来说，该项目的目标是模拟足够的 Web 浏览器子集，以便用于测试和挖掘真实世界的 Web 应用程序。\n\n最新版本的 jsdom 运行环境需要 Node.js v14 或者更高的版本。（jsdom v20 以下版本依旧可以在 Node.js 以前的版本使用，但是我们已经不支持维护了。）\n\n## 基本用法\n\n<!-- prettier-ignore-start -->\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n<!-- prettier-ignore-end -->\n\n为了使用 jsdom，主要用到 jsdom 主模块的一个命名导出的 `JSDOM` 构造函数。往构造器传递一个字符串，将会得到一个 `JSDOM` 构造实例对象，这个对象有很多实用的属性，特别是 `window` 对象：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); // \"Hello world\"\n```\n<!-- prettier-ignore-end -->\n\n（请注意，jsdom 会像浏览器一样解析您传递的 HTML，包括隐含的 `<html>`，`<head>` 和 `<body>` 标记。）\n\n生成的对象是 `JSDOM` 类的一个实例，其中包括 `window` 对象在内的许多有用的属性和方法。一般来说，它可以用来从“外部”对 jsdom 进行操作，而这些操作对于普通 DOM API 来说是不可能的。对于不需要任何功能的简单场景，我们推荐使用类似的编码模式\n\n<!-- prettier-ignore-start -->\n```js\nconst { window } = new JSDOM(`...`);\n// or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n<!-- prettier-ignore-end -->\n\n下面是关于 `JSDOM` 类所能做的一切的完整文档，在“`JSDOM` 对象 API”部分。\n\n## 定制 jsdom\n\n`JSDOM` 构造函数接受第二个参数，可以用以下方式定制您的 jsdom。\n\n### 简单选项\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(``, {\n  url: \"https://example.org/\",\n  referrer: \"https://example.com/\",\n  contentType: \"text/html\",\n  includeNodeLocations: true,\n  storageQuota: 10000000\n});\n```\n<!-- prettier-ignore-end -->\n\n- `url` 设置的值可以通过 `window.location`，`document.URL` 和 `document.documentURI` 来返回，并会影响文档中相关 URL 的解析以及获取子资源时使用的同源限制和 referrer。默认值为`\"about:blank\"`。\n- `referrer` 仅仅影响 `document.referrer` 的值。默认没有引用（即为空字符串）。\n- `contentType` 影响 `document.contentType` 的值，是按照 HTML 解析文档还是 XML 来解析。它的值如果不是 [HTML MIME 类型](https://mimesniff.spec.whatwg.org/#html-mime-type) 或 [XML MIME 类型](https://mimesniff.spec.whatwg.org/#xml-mime-type) 值的话将会抛出异常。默认值为`\"text/html\"`。如果存在 `charset` 参数，它会影响[二进制数据处理](#编码嗅探)。\n- `includeNodeLocations` 保留由 HTML 解析器生成的位置信息，允许您使用 `nodeLocation()` 方法（如下所述）检索它。它还能确保在 `<script>` 元素内运行的代码的异常堆栈跟踪中报告的行号是正确的。默认值为 `false` 以提供最佳性能，并且不能与 XML 内容类型一起使用，因为我们的 XML 解析器不支持位置信息。\n- `storageQuota` 是 `localStorage` 和 `sessionStorage` 使用的单独存储区域的代码单元的最大大小。尝试存储大于此限制的数据将导致抛出 `DOMException`。默认情况下，受 HTML 规范的启发，每个源设置为 5,000,000 个代码单元。\n\n请注意，`url` 和 `referrer` 在使用之前已经被规范化了，例如：如果你传入 `\"https:example.com\"`，jsdom 会自动规范化解释为 `\"https://example.com/\"`。如果你传递了一个不可解析的 URL，该调用将抛出错误。（URL 根据 [URL 标准](https://url.spec.whatwg.org/)进行分析和序列化。）\n\n### 执行脚本\n\njsdom 最强大的功能是它可以在 jsdom 中执行脚本。这些脚本可以修改页面的内容并访问 jsdom 实现的所有 Web 平台 API。\n\n但是，这在处理不可信内容时也非常危险。jsdom 沙箱并不是万无一失的，在 DOM 的 `<script>` 内部运行的代码如果足够深入，就可以访问 Node.js 环境，从而访问您的计算机。因此，默认情况下，执行嵌入在 HTML 中的脚本的功能是禁用的：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`);\n\n// 脚本默认将不会执行：\ndom.window.document.body.children.length === 1;\n```\n<!-- prettier-ignore-end -->\n\n要在页面内启用脚本，可以使用 `runScripts: \"dangerously\"` 选项：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`, { runScripts: \"dangerously\" });\n\n// 脚本将执行并修改 DOM：\ndom.window.document.body.children.length === 2;\n```\n<!-- prettier-ignore-end -->\n\n我们再次强调只有在提供给 jsdom 的代码是你已知道是安全的才可使用它。如果您运行了任意用户提供的或 Internet 上的不可信的 Node.js 代码，可能会危及您的计算机。\n\n假如你想通过 `<script src=\"\">` 来执行外部脚本，你需要确保已经加载了它们。为此，请添加选项 `resources: \"usable\"` [如下所述](#加载子资源)。（出于此处讨论的原因，您可能还需要设置 `url` 选项。）\n\n除非 `runScripts` 设置为 `\"dangerously\"`，否则事件处理属性（如`<div onclick=\"\">`）也将受此选项控制不起作用。（但是，事件处理函数属性，比如 `div.onclick = ...`，将忽略 `runScripts` 参数并且会起作用。）\n\n如果您只是试图从“外部”执行脚本，而不是通过 `<script>` 元素和事件处理属性从“内部”运行，则可以使用 `runScripts: \"outside-only\"` 选项，这使得所有 JavaScript 规范提供的全局变量的新副本都可以安装在 `window` 上。 这包括诸如 `window.Array`、`window.Promise` 等等。值得注意的是，它还包括 `window.eval` 可以用来运行脚本，运行时将 jsdom 的 `window` 作为全局：\n\n<!-- prettier-ignore-start -->\n```js\nconst { window } = new JSDOM(``, { runScripts: \"outside-only\" });\n\nwindow.eval(`document.body.innerHTML = \"<p>Hello, world!</p>\";`);\nwindow.document.body.children.length === 1;\n```\n<!-- prettier-ignore-end -->\n\n由于性能原因，默认情况下会关闭此功能，但可以安全启用。\n\n（注意，默认配置下，不设置 `runScripts`，`window.Array`、`window.eval`等的值会与外部 Node.js 环境提供的值相同。即` window.eval === eval` 会成立，所以 `window.eval` 不会以有用的方式运行脚本。）\n\n我们强烈建议不要试图通过将 jsdom 和 Node 全局环境混合在一起（例如，通过执行 `global.window = dom.window`）来“执行脚本”，然后在 Node 全局环境中执行脚本或测试代码。相反，您应该像对待浏览器一样对待 jsdom，并使用 `window.eval` 或 `runScripts: \"dangerously\"` 来运行需要访问 jsdom 环境内的 DOM 的所有脚本和测试。例如，这可能需要创建一个 browserify 包作为 `<script>` 元素执行 - 就像在浏览器中一样。\n\n最后，对于高级用例，您可以使用 `dom.getInternalVMContext()` 方法，如下所述。\n\n### 假装成一个视觉浏览器\n\njsdom 没有渲染可视内容的能力，并且默认情况下会像无头浏览器一样工作。它通过 API（如 `document.hidden`）向网页提供提示，表明其内容不可见。\n\n当 `pretendToBeVisual` 选项设置为 true 时，jsdom 会假装它正在呈现并显示内容。它是这样做的：\n\n- 更改 `document.hidden` 以返回 `false` 而不是 `true`\n- 更改 `document.visibilityState` 以返回 `\"visible\"` 而不是 `\"prerender\"`\n- 启用 `window.requestAnimationFrame()` 和 `window.cancelAnimationFrame()` 方法，否则不存在\n\n<!-- prettier-ignore-start -->\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp => {\n  console.log(timestamp > 0);\n});\n```\n<!-- prettier-ignore-end -->\n\n请注意，jsdom 仍然[不做任何布局或渲染](#未实现的-web-平台部分)，因此这实际上只是假装为可视化，而不是实现真正的可视化 Web 浏览器将实现的部分。\n\n### 加载子资源\n\n#### 基础选项\n\n默认情况下，jsdom 不会加载任何子资源，如脚本，样式表，图像或 iframe。如果您希望 jsdom 加载这些资源，则可以传递 `resources: \"usable\"` 选项，该选项将加载所有可用资源。资源列表如下：\n\n- 通过 `<frame>` 和 `<iframe>` 加载 frame 和 iframe\n- 通过 `<link rel=\"stylesheet\">` 加载样式\n- 通过 `<script>` 加载脚本，但是前提是 `runScripts: \"dangerously\"` 设置了\n- 通过 `<img>` 加载图片，但是前提是 `canvas` npm 包已安装（详见下面的[支持 Canvas](#支持-canvas)）\n\n尝试加载资源时，请记住 `url` 选项的默认值是 `\"about:blank\"`，这意味着通过相对 URL 包含的任何资源都将无法加载。（针对 URL `about:blank` 解析 URL `/something` 的结果是一个错误。）因此，在这些情况下，您可能希望为 `url` 选项设置一个非默认值，或使用自动执行此操作的[便捷的 API](#便捷的-api) 之一。\n\n#### 高级配置\n\n要更全面地自定义 jsdom 的资源加载行为，可以将 `ResourceLoader` 类的实例作为 `resources` 选项值传递：\n\n<!-- prettier-ignore-start -->\n```js\nconst resourceLoader = new jsdom.ResourceLoader({\n  proxy: \"http://127.0.0.1:9001\",\n  strictSSL: false,\n  userAgent: \"Mellblomenator/9000\",\n});\nconst dom = new JSDOM(``, { resources: resourceLoader });\n```\n<!-- prettier-ignore-end -->\n\n`ResourceLoader` 构造函数的三个选项是：\n\n- `proxy` 是要使用的 HTTP 代理的地址。\n- `strictSSL` 可以设置为 false 以禁用 SSL 证书有效的要求。\n- `userAgent` 影响发送的 `User-Agent` 标头，从而影响 `navigator.userAgent` 的结果值。 它默认为 <code>\\`Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/${jsdomVersion}\\`</code>。\n\n您可以通过继承 `ResourceLoader` 并覆盖 `fetch()` 方法来进一步自定义资源获取。例如，覆盖指定 URL 返回的内容：\n\n<!-- prettier-ignore-start -->\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    // 重写此脚本的内容以执行一些不寻常的操作。\n    if (url === \"https://example.com/some-specific-script.js\") {\n      return Promise.resolve(Buffer.from(\"window.someGlobal = 5;\"));\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n<!-- prettier-ignore-end -->\n\njsdom 在遇到之前说到的“可用”资源时会调用自定义资源加载器的 `fetch()` 方法。该方法接受一个 URL 字符串，以及一些在调用 `super.fetch()` 时应透传的选项。它必须返回一个 Node.js 的 `Buffer` 对象的 promise，或者如果有意不加载资源则返回 `null`。一般来说，大多数情况下都希望像上面代码一样委托给 `super.fetch()`。\n\n可以在 `fetch()` 中收到的选项之一是获取资源的元素（如果适用）。\n\n<!-- prettier-ignore-start -->\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    if (options.element) {\n      console.log(`Element ${options.element.localName} is requesting the url ${url}`);\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n<!-- prettier-ignore-end -->\n\n### 虚拟控制台\n\n像网页浏览器一样，jsdom 也具有“控制台”的概念。通过在文档内执行的脚本以及来自 jsdom 本身实现的信息和记录会从页面直接发送过来。我们将用户可控制的控制台称为“虚拟控制台”，以便将其与 Node.js `console` API 和页面内部的 `window.console` API 区分开来。\n\n默认情况下，`JSDOM` 构造函数将返回一个具有虚拟控制台的实例，该虚拟控制台将其所有输出转发到 Node.js 控制台。为了创建自己的虚拟控制台并将其传递给 jsdom，可以通过执行下面代码来覆盖此默认值\n\n<!-- prettier-ignore-start -->\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n<!-- prettier-ignore-end -->\n\n这样的代码将创建一个没有任何行为的虚拟控制台。您可以为所有可能的控制台方法添加事件侦听器来为其提供行为：\n\n<!-- prettier-ignore-start -->\n```js\nvirtualConsole.on(\"error\", () => { ... });\nvirtualConsole.on(\"warn\", () => { ... });\nvirtualConsole.on(\"info\", () => { ... });\nvirtualConsole.on(\"dir\", () => { ... });\n// ... etc. See https://console.spec.whatwg.org/#logging\n```\n<!-- prettier-ignore-end -->\n\n（请注意，最好在调用 `new JSDOM()` 之前设置这些事件侦听器，因为在解析期间可能会发生错误或控制台调用脚本错误。）\n\n如果你只是想将虚拟控制台输出重定向到另一个控制台，比如默认的 Node.js，你可以这样做\n\n<!-- prettier-ignore-start -->\n```js\nvirtualConsole.sendTo(console);\n```\n<!-- prettier-ignore-end -->\n\n还有一个特殊的事件，`\"jsdomError\"`，它的触发将通过错误对象来记录 jsdom 本身的错误。这与错误消息在 Web 浏览器控制台中的显示方式类似，即使它们不是由 console.error 输出的。到目前为止，错误会按照下面的方式输出：\n\n- 加载或解析子资源时出错（脚本，样式表，frames 和 iframe）\n- 不是由 window `onerror` 事件处理程序处理的脚本执行错误，它将会返回 `true` 或调用 `event.preventDefault()`\n- 由于调用 jsdom 没有实现的方法而导致的错误，例如 `window.alert`，兼容性的 Web 浏览器都实现了这些方法\n\n如果您使用 `sendTo(c)` 将错误发送给 `c`，则默认情况下，它将使用来自`\"jsdomError\"`事件的信息调用 `c.error(errorStack[, errorDetail])`。如果您希望保持事件与方法调用的严格的一对一映射，并且可能自己处理`\"jsdomError\"`，那么您可以执行\n\n<!-- prettier-ignore-start -->\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n<!-- prettier-ignore-end -->\n\n### Cookie 容器\n\n像网页浏览器一样，jsdom 也具有 cookie 容器的概念，存储 HTTP cookie。在文档的同一个域上一个 URL，并且没有标记为 HTTP-only 的 cookies，可以通过`document.cookie` API 来访问。此外，cookie 容器中的所有 cookie 都会影响子资源的加载。\n\n默认情况下，`JSDOM` 构造函数将返回一个带有空 cookie 的实例。要创建自己的 cookie 容器并将其传递给 jsdom，可以通过以下代码来覆盖默认值\n\n<!-- prettier-ignore-start -->\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n<!-- prettier-ignore-end -->\n\n如果您想要在多个 jsdom 中共享同一个 cookie 容器，或者提前使用特定的值来填充 cookie 容器，这将非常有用。\n\nCookie jar 由 [tough-cookie](https://www.npmjs.com/package/tough-cookie) 包提供。`jsdom.CookieJar`构造函数是 tough-cookie cookie 容器的子类，并且默认设置了 `looseMode：true` 选项，因为它[更符合浏览器的行为方式](https://github.com/whatwg/html/issues/804)。如果您想自己使用 tough-cookie 的方法和类，则可以使用 `jsdom.toughCookie` 模块导出来访问使用 jsdom 打包的 tough-cookie 模块实例。\n\n### 在解析之前进行干预\n\njsdom 允许您在很早的时候介入创建 jsdom：创建 Window 和 Document 对象之后，但在解析任何 HTML 并使用节点填充文档之前：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<p>Hello</p>`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () => { /* ... */ };\n  }\n});\n```\n<!-- prettier-ignore-end -->\n\n如果您想以某种方式修改环境，例如为 jsdom 不支持的 Web 平台 API 添加 shim，这将特别有用。\n\n## `JSDOM` object API\n\n一旦你构建了一个 `JSDOM` 对象，它将具有以下有用的功能：\n\n### Properties\n\n`window` 属性: `window` 对象的 key 从 `Window` 对象检索而来。\n\n`virtualConsole` 和 `cookieJar`：可以传入或者使用默认值。\n\n### 通过 `serialize()` 序列化 document\n\n`serialize()` 方法将返回文档的 [HTML 序列化](https://html.spec.whatwg.org/#html-fragment-serialisation-algorithm)，包括 doctype：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<!DOCTYPE html>hello`);\n\ndom.serialize() === \"<!DOCTYPE html><html><head></head><body>hello</body></html>\";\n\n// 对比:\ndom.window.document.documentElement.outerHTML === \"<html><head></head><body>hello</body></html>\";\n```\n<!-- prettier-ignore-end -->\n\n### 通过 `nodeLocation(node)` 获取节点的源位置信息\n\n`nodeLocation()`方法将查找 DOM 节点在源文档中的位置，并返回节点的 [parse5 位置信息](https://www.npmjs.com/package/parse5#options-locationinfo)：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(\n  `<p>Hello\n    <img src=\"foo.jpg\">\n  </p>`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; // implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   // null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      // { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); // { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    // { startOffset: 13, endOffset: 32 }\n```\n<!-- prettier-ignore-end -->\n\n请注意，只有设置了 `includeNodeLocations` 选项才能使用此功能；由于性能原因这个选项默认为关闭。\n\n### 使用 `getInternalVMContext()` 与 Node.js `vm` 模块交互\n\nNode.js 的内置 [`vm`](https://nodejs.org/api/vm.html) 模块是 jsdom 脚本运行魔法的基础。一些高级用例，例如预编译脚本然后多次运行，可以通过直接使用 `vm` 模块和 jsdom 创建的 `Window` 实现。\n\n可以使用 `getInternalVMContext()` 方法获取与 `vm` API 一起使用的[上下文化的全局对象](https://nodejs.org/api/vm.html#vm_what_does_it_mean_to_contextify_an_object)：\n\n<!-- prettier-ignore-start -->\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst script = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\nconst vmContext = dom.getInternalVMContext();\n\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\n\nconsole.assert(dom.window.ran === 3);\n```\n<!-- prettier-ignore-end -->\n\n这是高级功能，除非您有特殊的需求，否则我们建议坚持使用普通的 DOM API（如 `window.eval()` 或 `document.createElement(\"script\")`）。\n\n请注意，如果在没有设置 `runScripts` 的情况下创建了 `JSDOM` 实例，或者如果您 [在 Web 浏览器中使用 jsdom](#在-web-浏览器中运行-jsdom)，此方法将抛出异常。\n\n### 通过 `reconfigure(settings)` 重新配置 jsdom\n\n`window.top` 属性在规范中被标记为 `[Unforgeable]`，这意味着它是一个不可配置的私有属性，因此在 jsdom 内运行的普通代码是不能覆盖或隐藏它，即使使用 `Object.defineProperty`。\n\n同样，目前在 jsdom 中是不能够处理导航相关信息的（比如设置 `window.location.href = \"https://example.com/\"`）；这样做会导致在虚拟控制台报 `\"jsdomError\"` 错误，说明此功能未实现，并且没有任何变化：也将不会有新的 `Window` 或 `Document` 对象，并且现有 `window` 的 `location` 对象仍保持当前所有相同的属性值。\n\n但是，如果您从 jsdom 窗口之外进行操作，例如在一些创建 jsdom 的测试框架中，可以使用特殊的 `reconfigure()` 方法覆盖其中的一个或两个：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({\n  windowTop: myFakeTopForTesting,\n  url: \"https://example.com/\",\n});\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https://example.com/\";\n```\n<!-- prettier-ignore-end -->\n\n请注意，更改 jsdom 的 URL 将影响所有返回当前 document URL 的 API，例如 `window.location`、`document.URL` 和 `document.documentURI `，以及文档中相对 URL 的解析以及同源检查和提取子资源时使用的来源。但是，它不会执行导航到该 URL 的内容；DOM 的内容将保持不变，并且不会创建 `Window`，`Document`等新的实例。\n\n## 便捷的 API\n\n### `fromURL()`\n\n除了 `JSDOM` 构造函数本身之外，jsdom 还提供了一个返回 Promise 的工厂方法，用于通过 URL 构建一个 jsdom 实例：\n\n<!-- prettier-ignore-start -->\n```js\nJSDOM.fromURL(\"https://example.com/\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n<!-- prettier-ignore-end -->\n\n如果 URL 有效且请求成功，则 `onFullfilled` 回调执行并返回 `JSDOM` 实例。任何 URL 重定向都将遵循其最终目的地。\n\n`fromURL()` 提供的选项与提供给 `JSDOM` 构造函数的选项类似，但具有以下额外的限制和后果：\n\n- `url` 和 `contentType` 参数不能被提供。\n- `referrer` 选项用作初始请求的 HTTP `Referer` 请求头。\n- `resources` 选项也会影响初始请求；这很有用，例如，如果您想配置代理（见上文）。\n- 生成的 jsdom 的 URL、内容类型和来源是由响应来决定。\n- 任何通过 HTTP `Set-Cookie` 响应头设置的 cookie 都存储在 jsdom 的 cookie 容器中。同样，已提供的 cookie 容器中的任何 cookie 都会作为 HTTP `Cookie` 请求头发送。\n\n### `fromFile()`\n\n与 `fromURL()` 类似，jsdom 还提供了一个 `fromFile()` 工厂方法，用于从文件名构建 jsdom：\n\n<!-- prettier-ignore-start -->\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n<!-- prettier-ignore-end -->\n\n如果可以打开给定的文件，则 `onFullfilled` 回调执行并返回 `JSDOM` 实例。和 Node.js API 一样，文件名是相对于当前工作目录的。\n\n`fromFile()` 提供的选项与提供给 `JSDOM` 构造函数的选项相似，但具有以下额外的默认值：\n\n- `url` 选项将默认为给定文件名相对应的文件 URL，而不是 `\"about：blank\"`。\n- 假如给定的文件名是以 `.xht`、`.xhtml` 或者 `.xml` 为后缀的话，`contentType` 选项默认为 `\"application/xhtml+xml\"`；反之为 `\"text/html\"`。\n\n### `fragment()`\n\n对于最简单的情况，你可能不需要一个完整的 `JSDOM` 实例及其所有相关的功能。您甚至可能不需要 `Window` 或 `Document`！相反，你只需要解析一些 HTML 片段，并获得一个你可以操作的 DOM 对象。为此，我们提供了 `fragment()`，它可以从给定的字符串中创建一个` DocumentFragment`：\n\n<!-- prettier-ignore-start -->\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p><p><strong>Hi!</strong>`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent === \"Hi!\";\n// etc.\n```\n<!-- prettier-ignore-end -->\n\n`frag` 是 [`DocumentFragment`](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment) 的实例对象，其内容是通过提供的字符串解析创建的。解析是通过使用 `<template>` 元素完成的，因此您可以在其中包含任何元素（包括具有奇怪解析规则的元素，如 `<td>`）。还需要注意的是，生成的 `DocumentFragment` 不会有[关联的浏览上下文](https://html.spec.whatwg.org/multipage/#concept-document-bc)：即元素的 `ownerDocument` 将有一个空的 `defaultView` 属性，资源不会加载，等等。\n\n`fragment()` 工厂函数的所有调用结果的 `DocumentFragments` 实例都会共享相同的 `Document`。这允许多次调用 `fragment()` 而没有额外的开销。但这也意味着对 `fragment()` 的调用不能用任何选项自定义。\n\n请注意，对 `DocumentFragments` 的序列化并不像使用 `JSDOM` 对象那样容易。如果你需要序列化你的 DOM ，你应该直接使用 `JSDOM` 构造函数。但对于包含单个元素的片段的特殊情况，通过常规方法就很容易做到。\n\n<!-- prettier-ignore-start -->\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p>`);\nconsole.log(frag.firstChild.outerHTML); // logs \"<p>Hello</p>\"\n```\n<!-- prettier-ignore-end -->\n\n## 其他值得注意的功能\n\n### 支持 Canvas\n\njsdom 支持使用 [`canvas`](https://www.npmjs.com/package/canvas) 包来扩展任何使用 canvas API 的 `<canvas>` 元素。为了做到这一点，您需要将 `canvas` 作为依赖项加入到您的项目中，和 `jsdom` 包并列。如果 jsdom 可以找到 `canvas` 包，它将使用它，但是如果它不存在，那么 `<canvas>` 元素的行为就像 `<div>` 一样。从 jsdom v13 开始，需要 `canvas` 的 2.x 版本；不再支持 1.x 版。\n\n### 编码嗅探\n\n除了提供一个字符串外，`JSDOM` 构造函数还支持 Node.js [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)或标准 JavaScript 二进制数据类型（如 `ArrayBuffer`，`Uint8Array`，`DataView` 等）的形式提供二进制数据。当完成后，jsdom 将就像浏览器一样从提供的字节进行[嗅探编码](https://html.spec.whatwg.org/multipage/syntax.html#encoding-sniffing-algorithm)，扫描 `<meta charset>` 标签。\n\n如果提供的 `contentType` 选项包含 `charset` 参数，则该编码将覆盖嗅探的编码 - 除非存在 UTF-8 或 UTF-16 BOM，在这种情况下嗅探的编码优先。（同样就像浏览器。）\n\n这种编码嗅探也适用于 `JSDOM.fromFile()` 和 `JSDOM.fromURL()`。在后一种情况下，就像在浏览器中一样，任何与响应一起发送的 `Content-Type` 头信息优先级更高，与构造函数的 `contentType` 选项的方式相同。\n\n请注意，在许多情况下，提供字节这种方式可能比提供字符串更好。例如，如果您试图使用 Node.js 的 `buffer.toString('utf-8')` API，则 Node.js 将不会去除任何前导 BOM。如果您将此字符串提供给 jsdom，它会逐字解释，从而使 BOM 保持不变。但 jsdom 的二进制数据解码代码将剥离前导的 BOM，就像浏览器一样；在这种情况下，直接提供 `buffer` 将会得到想要的结果。\n\n### 关闭 jsdom\n\njsdom 中定义的定时器（通过 `window.setTimeout()` 或 `window.setInterval()` 设置）将在 window 上下文中执行代码。由于进程在不活跃的情况下无法执行未来的定时器代码，所以卓越的 jsdom 定时器将保持您的 Node.js 进程处于活动状态。同样，对象不活跃的情况下也没有办法在对象的上下文中执行代码，卓越的 jsdom 定时器将阻止垃圾回收调度它们的 window。\n\n如果你想确保关闭 jsdom 窗口，使用 `window.close()`，它将终止所有正在运行的定时器（并且还会删除 `window` 和 `document` 上的任何事件监听器）。\n\n### 在 Web 浏览器中运行 jsdom\n\n使用 [browserify](http://browserify.org/) 模块，jsdom 某些方面也支持在 Web 浏览器中运行。也就是说，在 Web 浏览器中，您可以使用被 `browserify` 模块编译过的 jsdom 去创建完全独立的普通 JavaScript 对象集，其外观和行为与浏览器的现有 DOM 对象非常相似，但完全独立于它们，也就是“虚拟 DOM”！\n\njsdom 的主要目标对象仍然是 Node.js，因此我们使用仅存在于最新 Node.js 版本中的语言特性功能。因此，在旧版浏览器可能无法正常工作。（即使编译也不会有多大帮助：我们在整个 jsdom 代码库中广泛使用 `Proxy`。）\n\n值得注意的是，jsdom 在 Web Worker 中能很好的运行。项目的开发者 [@lawnsea](https://github.com/lawnsea/) 使这一功能点成为可能，他发表了一篇关于他的[项目的论文](https://pdfs.semanticscholar.org/47f0/6bb6607a975500a30e9e52d7c9fbc0034e27.pdf)，该论文就使用了这种能力。\n\n在 Web 浏览器中运行 jsdom 时，并非所有的工作都完美。有些情况下，这是由于基础的条件限制（比如没有文件系统访问），但有些情况下也是因为我们没有花足够的时间去进行适当的小调整。欢迎大家来提 bug。\n\n### 使用 Chrome 开发者工具调试 DOM\n\n可以使用 Chrome 开发者工具来调试 Node.js 程序。请参阅[官方文档](https://nodejs.org/en/docs/inspector/)了解如何使用。\n\n默认情况下，jsdom 元素在控制台中被格式化为普通的旧 JS 对象。为了便于调试，可以使用[jsdom-devtools-formatter](https://github.com/jsdom/jsdom-devtools-formatter)，它可以让你像真正的 DOM 元素一样调试它们。\n\n## 注意事项\n\n### 异步脚本加载\n\n使用 jsdom 时，开发者在加载异步脚本时经常遇到麻烦。许多页面异步加载脚本，但无法分辨脚本什么时候完成，因此无法知道何时是运行代码并检查生成的 DOM 结构的好时机。这是一个基本的限制；我们无法预测网页上的哪些脚本会做什么，因此无法告诉您脚本何时加载完毕。\n\n这个问题可以通过几种方法来解决。如果您能控制页面逻辑，最好的方法是使用脚本加载器提供的机制来检测何时加载完成。例如，如果您使用像 RequireJS 这样的模块加载器，代码可能如下所示：\n\n<!-- prettier-ignore-start -->\n```js\n// On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () => {\n  console.log(\"ready to roll!\");\n};\n```\n<!-- prettier-ignore-end -->\n\n<!-- prettier-ignore-start -->\n```html\n<!-- Inside the HTML you supply to jsdom -->\n<script>\nrequirejs([\"entry-module\"], () => {\n  window.onModulesLoaded();\n});\n</script>\n```\n<!-- prettier-ignore-end -->\n\n如果您不能控制该页面，则可以尝试其他解决方法，例如轮询检查特定元素是否存在。\n\n有关更多详细信息，请查看[#640](https://github.com/tmpvar/jsdom/issues/640)中的讨论，尤其是 [@matthewkastor](https://github.com/matthewkastor) 的[深刻见解](https://github.com/tmpvar/jsdom/issues/640#issuecomment-22216965)。\n\n### 未实现的 Web 平台部分\n\n目前 jsdom 中有很多缺失的 API，尽管我们也想要在 jsdom 中添加新的功能并保持最新的 Web 规范。请随时为缺失的任何内容提交 issue，但我们是一个很小并且忙碌的团队，因此大家一起来提交 pull request 可能会更好。\n\njsdom 的一些特性是由我们的依赖项提供的。这方面值得注意的文档包括我们的 [CSS 选择器引擎](https://github.com/dperini/nwsapi/wiki/CSS-supported-selectors) [`nwsapi`](https://github.com/dperini/nwsapi)。\n\n除了我们尚未拥有的功能之外，还有两个主要功能目前超出了 jsdom 的范围。这些是：\n\n- **导航**：在点击链接或赋值 `location.href` 或类似操作时可以更改全局对象和所有其他的对象。\n- **布局**：计算 CSS 元素的视觉布局的能力，这会影响诸如 `getBoundingClientRects()` 或者诸如 `offsetTop` 之类的属性。\n\n目前，jsdom 对某些功能的某些方面具有虚拟行为，例如操作导航时向虚拟控制台发送“未实现的”`\"jsdomError\"`，或者为许多与布局相关的属性返回 0。您通常可以在代码中解决这些限制，例如通过在爬网过程中为每个页面创建新的 `JSDOM` 实例，或使用 `Object.defineProperty()` 更改各种与布局相关的 getter 和方法的返回值\n\n请注意，相同领域中的其他工具（如 PhantomJS）确实支持这些功能。在 wiki 上，我们有关于 [jsdom 与 PhantomJS 比较](https://github.com/jsdom/jsdom/wiki/jsdom-vs.-PhantomJS)的更完整的介绍。\n\n## 支持 jsdom\n\njsdom 是一个社区驱动的项目，由[志愿者](https://github.com/orgs/jsdom/people)团队维护。您可以通过以下方式支持 jsdom：\n\n- 在 Tidelift 订阅中[获得对 jsdom 的专业支持](https://tidelift.com/subscription/pkg/npm-jsdom?utm_source=npm-jsdom&utm_medium=referral&utm_campaign=readme)。Tidelift 帮助我们实现开源的可持续发展，同时为团队提供维护、许可和安全方面的保证。\n- 直接对项目[做贡献](https://github.com/jsdom/jsdom/blob/master/Contributing.md)。\n\n## 获取帮助\n\n如果您需要 jsdom 的帮助，请随时使用以下任何方式：\n\n- [邮件组](https://groups.google.com/group/jsdom)（最好以 “how do I” 的形式提问）\n- [提 issue](https://github.com/jsdom/jsdom/issues)（最好用来提 bug）\n- Matrix 房间：[#jsdom:matrix.org](https://matrix.to/#/#jsdom:matrix.org)\n\n---\n\n原文地址：[jsdom/jsdom: A JavaScript implementation of various web standards, for use with Node.js](https://github.com/jsdom/jsdom)\n\n此翻译由 [zjffun/translated-document](https://github.com/zjffun/translated-document) 提供，在 GitHub 上[完善此翻译](https://github.com/zjffun/translated-document/edit/main/files/zh-cn/github/jsdom.md)。\n",
  "translatedOwner": "zjffun",
  "translatedRepo": "translated-document",
  "translatedBranch": "main",
  "translatedRev": "5996abda1025dc8186e5d0919a170ded93c186f4",
  "viewerRelations": [
    {
      "id": "643acf9d26f2b8069d3c2edf",
      "fromRange": [1, 8],
      "toRange": [1, 12],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee0",
      "fromRange": [10, 34],
      "toRange": [14, 44],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee1",
      "fromRange": [36, 38],
      "toRange": [46, 48],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee2",
      "fromRange": [40, 58],
      "toRange": [50, 70],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee3",
      "fromRange": [60, 107],
      "toRange": [72, 125],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee4",
      "fromRange": [109, 127],
      "toRange": [127, 147],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee5",
      "fromRange": [129, 129],
      "toRange": [149, 149],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee6",
      "fromRange": [131, 140],
      "toRange": [151, 160],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee7",
      "fromRange": [142, 190],
      "toRange": [162, 216],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee8",
      "fromRange": [192, 231],
      "toRange": [218, 265],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ee9",
      "fromRange": [233, 246],
      "toRange": [267, 282],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eea",
      "fromRange": [248, 261],
      "toRange": [284, 299],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eeb",
      "fromRange": [263, 265],
      "toRange": [301, 303],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eec",
      "fromRange": [267, 271],
      "toRange": [305, 309],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eed",
      "fromRange": [273, 284],
      "toRange": [311, 324],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eee",
      "fromRange": [286, 310],
      "toRange": [326, 352],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eef",
      "fromRange": [312, 341],
      "toRange": [354, 385],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef0",
      "fromRange": [343, 363],
      "toRange": [387, 412],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef1",
      "fromRange": [365, 365],
      "toRange": [414, 414],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef2",
      "fromRange": [367, 385],
      "toRange": [416, 436],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef3",
      "fromRange": [387, 402],
      "toRange": [438, 455],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef4",
      "fromRange": [404, 425],
      "toRange": [457, 482],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef5",
      "fromRange": [427, 427],
      "toRange": [484, 484],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef6",
      "fromRange": [429, 431],
      "toRange": [486, 488],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef7",
      "fromRange": [433, 441],
      "toRange": [490, 498],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef8",
      "fromRange": [443, 447],
      "toRange": [500, 504],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2ef9",
      "fromRange": [449, 457],
      "toRange": [506, 514],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2efa",
      "fromRange": [459, 463],
      "toRange": [516, 520],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2efb",
      "fromRange": [465, 465],
      "toRange": [522, 522],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2efc",
      "fromRange": [467, 492],
      "toRange": [524, 553],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2efd",
      "fromRange": [494, 507],
      "toRange": [555, 568],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2efe",
      "fromRange": [509, 514],
      "toRange": [570, 575],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    },
    {
      "id": "643acf9d26f2b8069d3c2eff",
      "fromRange": [516, 522],
      "toRange": [577, 589],
      "originalFromViewerContentRev": "906a2a3812c5ba113e045b0ca264996c374cd488",
      "originalToViewerContentRev": "93f312a7e5e399c152aa3ab3f04c87a4b17301e7"
    }
  ],
  "viewerContents": {
    "906a2a3812c5ba113e045b0ca264996c374cd488": "<h1 align=\"center\">\n    <img width=\"100\" height=\"100\" src=\"logo.svg\" alt=\"\"><br>\n    jsdom\n</h1>\n\njsdom is a pure-JavaScript implementation of many web standards, notably the WHATWG [DOM](https://dom.spec.whatwg.org/) and [HTML](https://html.spec.whatwg.org/multipage/) Standards, for use with Node.js. In general, the goal of the project is to emulate enough of a subset of a web browser to be useful for testing and scraping real-world web applications.\n\nThe latest versions of jsdom require Node.js v14 or newer. (Versions of jsdom below v20 still work with previous Node.js versions, but are unsupported.)\n\n## Basic usage\n\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n\nTo use jsdom, you will primarily use the `JSDOM` constructor, which is a named export of the jsdom main module. Pass the constructor a string. You will get back a `JSDOM` object, which has a number of useful properties, notably `window`:\n\n```js\nconst dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); // \"Hello world\"\n```\n\n(Note that jsdom will parse the HTML you pass it just like a browser does, including implied `<html>`, `<head>`, and `<body>` tags.)\n\nThe resulting object is an instance of the `JSDOM` class, which contains a number of useful properties and methods besides `window`. In general, it can be used to act on the jsdom from the \"outside,\" doing things that are not possible with the normal DOM APIs. For simple cases, where you don't need any of this functionality, we recommend a coding pattern like\n\n```js\nconst { window } = new JSDOM(`...`);\n// or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n\nFull documentation on everything you can do with the `JSDOM` class is below, in the section \"`JSDOM` Object API\".\n\n## Customizing jsdom\n\nThe `JSDOM` constructor accepts a second parameter which can be used to customize your jsdom in the following ways.\n\n### Simple options\n\n```js\nconst dom = new JSDOM(``, {\n  url: \"https://example.org/\",\n  referrer: \"https://example.com/\",\n  contentType: \"text/html\",\n  includeNodeLocations: true,\n  storageQuota: 10000000\n});\n```\n\n- `url` sets the value returned by `window.location`, `document.URL`, and `document.documentURI`, and affects things like resolution of relative URLs within the document and the same-origin restrictions and referrer used while fetching subresources. It defaults to `\"about:blank\"`.\n- `referrer` just affects the value read from `document.referrer`. It defaults to no referrer (which reflects as the empty string).\n- `contentType` affects the value read from `document.contentType`, as well as how the document is parsed: as HTML or as XML. Values that are not a [HTML MIME type](https://mimesniff.spec.whatwg.org/#html-mime-type) or an [XML MIME type](https://mimesniff.spec.whatwg.org/#xml-mime-type) will throw. It defaults to `\"text/html\"`. If a `charset` parameter is present, it can affect [binary data processing](#encoding-sniffing).\n- `includeNodeLocations` preserves the location info produced by the HTML parser, allowing you to retrieve it with the `nodeLocation()` method (described below). It also ensures that line numbers reported in exception stack traces for code running inside `<script>` elements are correct. It defaults to `false` to give the best performance, and cannot be used with an XML content type since our XML parser does not support location info.\n- `storageQuota` is the maximum size in code units for the separate storage areas used by `localStorage` and `sessionStorage`. Attempts to store data larger than this limit will cause a `DOMException` to be thrown. By default, it is set to 5,000,000 code units per origin, as inspired by the HTML specification.\n\nNote that both `url` and `referrer` are canonicalized before they're used, so e.g. if you pass in `\"https:example.com\"`, jsdom will interpret that as if you had given `\"https://example.com/\"`. If you pass an unparseable URL, the call will throw. (URLs are parsed and serialized according to the [URL Standard](https://url.spec.whatwg.org/).)\n\n### Executing scripts\n\njsdom's most powerful ability is that it can execute scripts inside the jsdom. These scripts can modify the content of the page and access all the web platform APIs jsdom implements.\n\nHowever, this is also highly dangerous when dealing with untrusted content. The jsdom sandbox is not foolproof, and code running inside the DOM's `<script>`s can, if it tries hard enough, get access to the Node.js environment, and thus to your machine. As such, the ability to execute scripts embedded in the HTML is disabled by default:\n\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`);\n\n// The script will not be executed, by default:\ndom.window.document.body.children.length === 1;\n```\n\nTo enable executing scripts inside the page, you can use the `runScripts: \"dangerously\"` option:\n\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`, { runScripts: \"dangerously\" });\n\n// The script will be executed and modify the DOM:\ndom.window.document.body.children.length === 2;\n```\n\nAgain we emphasize to only use this when feeding jsdom code you know is safe. If you use it on arbitrary user-supplied code, or code from the Internet, you are effectively running untrusted Node.js code, and your machine could be compromised.\n\nIf you want to execute _external_ scripts, included via `<script src=\"\">`, you'll also need to ensure that they load them. To do this, add the option `resources: \"usable\"` [as described below](#loading-subresources). (You'll likely also want to set the `url` option, for the reasons discussed there.)\n\nEvent handler attributes, like `<div onclick=\"\">`, are also governed by this setting; they will not function unless `runScripts` is set to `\"dangerously\"`. (However, event handler _properties_, like `div.onclick = ...`, will function regardless of `runScripts`.)\n\nIf you are simply trying to execute script \"from the outside\", instead of letting `<script>` elements and event handlers attributes run \"from the inside\", you can use the `runScripts: \"outside-only\"` option, which enables fresh copies of all the JavaScript spec-provided globals to be installed on `window`. This includes things like `window.Array`, `window.Promise`, etc. It also, notably, includes `window.eval`, which allows running scripts, but with the jsdom `window` as the global:\n\n```js\nconst { window } = new JSDOM(``, { runScripts: \"outside-only\" });\n\nwindow.eval(`document.body.innerHTML = \"<p>Hello, world!</p>\";`);\nwindow.document.body.children.length === 1;\n```\n\nThis is turned off by default for performance reasons, but is safe to enable.\n\n(Note that in the default configuration, without setting `runScripts`, the values of `window.Array`, `window.eval`, etc. will be the same as those provided by the outer Node.js environment. That is, `window.eval === eval` will hold, so `window.eval` will not run scripts in a useful way.)\n\nWe strongly advise against trying to \"execute scripts\" by mashing together the jsdom and Node global environments (e.g. by doing `global.window = dom.window`), and then executing scripts or test code inside the Node global environment. Instead, you should treat jsdom like you would a browser, and run all scripts and tests that need access to a DOM inside the jsdom environment, using `window.eval` or `runScripts: \"dangerously\"`. This might require, for example, creating a browserify bundle to execute as a `<script>` element—just like you would in a browser.\n\nFinally, for advanced use cases you can use the `dom.getInternalVMContext()` method, documented below.\n\n### Pretending to be a visual browser\n\njsdom does not have the capability to render visual content, and will act like a headless browser by default. It provides hints to web pages through APIs such as `document.hidden` that their content is not visible.\n\nWhen the `pretendToBeVisual` option is set to `true`, jsdom will pretend that it is rendering and displaying content. It does this by:\n\n* Changing `document.hidden` to return `false` instead of `true`\n* Changing `document.visibilityState` to return `\"visible\"` instead of `\"prerender\"`\n* Enabling `window.requestAnimationFrame()` and `window.cancelAnimationFrame()` methods, which otherwise do not exist\n\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp => {\n  console.log(timestamp > 0);\n});\n```\n\nNote that jsdom still [does not do any layout or rendering](#unimplemented-parts-of-the-web-platform), so this is really just about _pretending_ to be visual, not about implementing the parts of the platform a real, visual web browser would implement.\n\n### Loading subresources\n\n#### Basic options\n\nBy default, jsdom will not load any subresources such as scripts, stylesheets, images, or iframes. If you'd like jsdom to load such resources, you can pass the `resources: \"usable\"` option, which will load all usable resources. Those are:\n\n* Frames and iframes, via `<frame>` and `<iframe>`\n* Stylesheets, via `<link rel=\"stylesheet\">`\n* Scripts, via `<script>`, but only if `runScripts: \"dangerously\"` is also set\n* Images, via `<img>`, but only if the `canvas` npm package is also installed (see \"[Canvas Support](#canvas-support)\" below)\n\nWhen attempting to load resources, recall that the default value for the `url` option is `\"about:blank\"`, which means that any resources included via relative URLs will fail to load. (The result of trying to parse the URL `/something` against the URL `about:blank` is an error.) So, you'll likely want to set a non-default value for the `url` option in those cases, or use one of the [convenience APIs](#convenience-apis) that do so automatically.\n\n#### Advanced configuration\n\nTo more fully customize jsdom's resource-loading behavior, you can pass an instance of the `ResourceLoader` class as the `resources` option value:\n\n```js\nconst resourceLoader = new jsdom.ResourceLoader({\n  proxy: \"http://127.0.0.1:9001\",\n  strictSSL: false,\n  userAgent: \"Mellblomenator/9000\",\n});\nconst dom = new JSDOM(``, { resources: resourceLoader });\n```\n\nThe three options to the `ResourceLoader` constructor are:\n\n- `proxy` is the address of an HTTP proxy to be used.\n- `strictSSL` can be set to false to disable the requirement that SSL certificates be valid.\n- `userAgent` affects the `User-Agent` header sent, and thus the resulting value for `navigator.userAgent`. It defaults to <code>\\`Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/${jsdomVersion}\\`</code>.\n\nYou can further customize resource fetching by subclassing `ResourceLoader` and overriding the `fetch()` method. For example, here is a version that overrides the response provided for a specific URL:\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    // Override the contents of this script to do something unusual.\n    if (url === \"https://example.com/some-specific-script.js\") {\n      return Promise.resolve(Buffer.from(\"window.someGlobal = 5;\"));\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\njsdom will call your custom resource loader's `fetch()` method whenever it encounters a \"usable\" resource, per the above section. The method takes a URL string, as well as a few options which you should pass through unmodified if calling `super.fetch()`. It must return a promise for a Node.js `Buffer` object, or return `null` if the resource is intentionally not to be loaded. In general, most cases will want to delegate to `super.fetch()`, as shown.\n\nOne of the options you will receive in `fetch()` will be the element (if applicable) that is fetching a resource.\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    if (options.element) {\n      console.log(`Element ${options.element.localName} is requesting the url ${url}`);\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\n### Virtual consoles\n\nLike web browsers, jsdom has the concept of a \"console\". This records both information directly sent from the page, via scripts executing inside the document, as well as information from the jsdom implementation itself. We call the user-controllable console a \"virtual console\", to distinguish it from the Node.js `console` API and from the inside-the-page `window.console` API.\n\nBy default, the `JSDOM` constructor will return an instance with a virtual console that forwards all its output to the Node.js console. To create your own virtual console and pass it to jsdom, you can override this default by doing\n\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n\nCode like this will create a virtual console with no behavior. You can give it behavior by adding event listeners for all the possible console methods:\n\n```js\nvirtualConsole.on(\"error\", () => { ... });\nvirtualConsole.on(\"warn\", () => { ... });\nvirtualConsole.on(\"info\", () => { ... });\nvirtualConsole.on(\"dir\", () => { ... });\n// ... etc. See https://console.spec.whatwg.org/#logging\n```\n\n(Note that it is probably best to set up these event listeners *before* calling `new JSDOM()`, since errors or console-invoking script might occur during parsing.)\n\nIf you simply want to redirect the virtual console output to another console, like the default Node.js one, you can do\n\n```js\nvirtualConsole.sendTo(console);\n```\n\nThere is also a special event, `\"jsdomError\"`, which will fire with error objects to report errors from jsdom itself. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by `console.error`. So far, the following errors are output this way:\n\n- Errors loading or parsing subresources (scripts, stylesheets, frames, and iframes)\n- Script execution errors that are not handled by a window `onerror` event handler that returns `true` or calls `event.preventDefault()`\n- Not-implemented errors resulting from calls to methods, like `window.alert`, which jsdom does not implement, but installs anyway for web compatibility\n\nIf you're using `sendTo(c)` to send errors to `c`, by default it will call `c.error(errorStack[, errorDetail])` with information from `\"jsdomError\"` events. If you'd prefer to maintain a strict one-to-one mapping of events to method calls, and perhaps handle `\"jsdomError\"`s yourself, then you can do\n\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n\n### Cookie jars\n\nLike web browsers, jsdom has the concept of a cookie jar, storing HTTP cookies. Cookies that have a URL on the same domain as the document, and are not marked HTTP-only, are accessible via the `document.cookie` API. Additionally, all cookies in the cookie jar will impact the fetching of subresources.\n\nBy default, the `JSDOM` constructor will return an instance with an empty cookie jar. To create your own cookie jar and pass it to jsdom, you can override this default by doing\n\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n\nThis is mostly useful if you want to share the same cookie jar among multiple jsdoms, or prime the cookie jar with certain values ahead of time.\n\nCookie jars are provided by the [tough-cookie](https://www.npmjs.com/package/tough-cookie) package. The `jsdom.CookieJar` constructor is a subclass of the tough-cookie cookie jar which by default sets the `looseMode: true` option, since that [matches better how browsers behave](https://github.com/whatwg/html/issues/804). If you want to use tough-cookie's utilities and classes yourself, you can use the `jsdom.toughCookie` module export to get access to the tough-cookie module instance packaged with jsdom.\n\n### Intervening before parsing\n\njsdom allows you to intervene in the creation of a jsdom very early: after the `Window` and `Document` objects are created, but before any HTML is parsed to populate the document with nodes:\n\n```js\nconst dom = new JSDOM(`<p>Hello</p>`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () => { /* ... */ };\n  }\n});\n```\n\nThis is especially useful if you are wanting to modify the environment in some way, for example adding shims for web platform APIs jsdom does not support.\n\n## `JSDOM` object API\n\nOnce you have constructed a `JSDOM` object, it will have the following useful capabilities:\n\n### Properties\n\nThe property `window` retrieves the `Window` object that was created for you.\n\nThe properties `virtualConsole` and `cookieJar` reflect the options you pass in, or the defaults created for you if nothing was passed in for those options.\n\n### Serializing the document with `serialize()`\n\nThe `serialize()` method will return the [HTML serialization](https://html.spec.whatwg.org/#html-fragment-serialisation-algorithm) of the document, including the doctype:\n\n```js\nconst dom = new JSDOM(`<!DOCTYPE html>hello`);\n\ndom.serialize() === \"<!DOCTYPE html><html><head></head><body>hello</body></html>\";\n\n// Contrast with:\ndom.window.document.documentElement.outerHTML === \"<html><head></head><body>hello</body></html>\";\n```\n\n### Getting the source location of a node with `nodeLocation(node)`\n\nThe `nodeLocation()` method will find where a DOM node is within the source document, returning the [parse5 location info](https://www.npmjs.com/package/parse5#options-locationinfo) for the node:\n\n```js\nconst dom = new JSDOM(\n  `<p>Hello\n    <img src=\"foo.jpg\">\n  </p>`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; // implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   // null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      // { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); // { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    // { startOffset: 13, endOffset: 32 }\n```\n\nNote that this feature only works if you have set the `includeNodeLocations` option; node locations are off by default for performance reasons.\n\n### Interfacing with the Node.js `vm` module using `getInternalVMContext()`\n\nThe built-in [`vm`](https://nodejs.org/api/vm.html) module of Node.js is what underpins jsdom's script-running magic. Some advanced use cases, like pre-compiling a script and then running it multiple times, benefit from using the `vm` module directly with a jsdom-created `Window`.\n\nTo get access to the [contextified global object](https://nodejs.org/api/vm.html#vm_what_does_it_mean_to_contextify_an_object), suitable for use with the `vm` APIs, you can use the `getInternalVMContext()` method:\n\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst script = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\nconst vmContext = dom.getInternalVMContext();\n\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\n\nconsole.assert(dom.window.ran === 3);\n```\n\nThis is somewhat-advanced functionality, and we advise sticking to normal DOM APIs (such as `window.eval()` or `document.createElement(\"script\")`) unless you have very specific needs.\n\nNote that this method will throw an exception if the `JSDOM` instance was created without `runScripts` set, or if you are [using jsdom in a web browser](#running-jsdom-inside-a-web-browser).\n\n### Reconfiguring the jsdom with `reconfigure(settings)`\n\nThe `top` property on `window` is marked `[Unforgeable]` in the spec, meaning it is a non-configurable own property and thus cannot be overridden or shadowed by normal code running inside the jsdom, even using `Object.defineProperty`.\n\nSimilarly, at present jsdom does not handle navigation (such as setting `window.location.href = \"https://example.com/\"`); doing so will cause the virtual console to emit a `\"jsdomError\"` explaining that this feature is not implemented, and nothing will change: there will be no new `Window` or `Document` object, and the existing `window`'s `location` object will still have all the same property values.\n\nHowever, if you're acting from outside the window, e.g. in some test framework that creates jsdoms, you can override one or both of these using the special `reconfigure()` method:\n\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({ windowTop: myFakeTopForTesting, url: \"https://example.com/\" });\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https://example.com/\";\n```\n\nNote that changing the jsdom's URL will impact all APIs that return the current document URL, such as `window.location`, `document.URL`, and `document.documentURI`, as well as the resolution of relative URLs within the document, and the same-origin checks and referrer used while fetching subresources. It will not, however, perform navigation to the contents of that URL; the contents of the DOM will remain unchanged, and no new instances of `Window`, `Document`, etc. will be created.\n\n## Convenience APIs\n\n### `fromURL()`\n\nIn addition to the `JSDOM` constructor itself, jsdom provides a promise-returning factory method for constructing a jsdom from a URL:\n\n```js\nJSDOM.fromURL(\"https://example.com/\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the URL is valid and the request is successful. Any redirects will be followed to their ultimate destination.\n\nThe options provided to `fromURL()` are similar to those provided to the `JSDOM` constructor, with the following additional restrictions and consequences:\n\n- The `url` and `contentType` options cannot be provided.\n- The `referrer` option is used as the HTTP `Referer` request header of the initial request.\n- The `resources` option also affects the initial request; this is useful if you want to, for example, configure a proxy (see above).\n- The resulting jsdom's URL, content type, and referrer are determined from the response.\n- Any cookies set via HTTP `Set-Cookie` response headers are stored in the jsdom's cookie jar. Similarly, any cookies already in a supplied cookie jar are sent as HTTP `Cookie` request headers.\n\n### `fromFile()`\n\nSimilar to `fromURL()`, jsdom also provides a `fromFile()` factory method for constructing a jsdom from a filename:\n\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the given file can be opened. As usual in Node.js APIs, the filename is given relative to the current working directory.\n\nThe options provided to `fromFile()` are similar to those provided to the `JSDOM` constructor, with the following additional defaults:\n\n- The `url` option will default to a file URL corresponding to the given filename, instead of to `\"about:blank\"`.\n- The `contentType` option will default to `\"application/xhtml+xml\"` if the given filename ends in `.xht`, `.xhtml`, or `.xml`; otherwise it will continue to default to `\"text/html\"`.\n\n### `fragment()`\n\nFor the very simplest of cases, you might not need a whole `JSDOM` instance with all its associated power. You might not even need a `Window` or `Document`! Instead, you just need to parse some HTML, and get a DOM object you can manipulate. For that, we have `fragment()`, which creates a `DocumentFragment` from a given string:\n\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p><p><strong>Hi!</strong>`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent === \"Hi!\";\n// etc.\n```\n\nHere `frag` is a [`DocumentFragment`](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) instance, whose contents are created by parsing the provided string. The parsing is done using a `<template>` element, so you can include any element there (including ones with weird parsing rules like `<td>`). It's also important to note that the resulting `DocumentFragment` will not have [an associated browsing context](https://html.spec.whatwg.org/multipage/#concept-document-bc): that is, elements' `ownerDocument` will have a null `defaultView` property, resources will not load, etc.\n\nAll invocations of the `fragment()` factory result in `DocumentFragment`s that share the same template owner `Document`. This allows many calls to `fragment()` with no extra overhead. But it also means that calls to `fragment()` cannot be customized with any options.\n\nNote that serialization is not as easy with `DocumentFragment`s as it is with full `JSDOM` objects. If you need to serialize your DOM, you should probably use the `JSDOM` constructor more directly. But for the special case of a fragment containing a single element, it's pretty easy to do through normal means:\n\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p>`);\nconsole.log(frag.firstChild.outerHTML); // logs \"<p>Hello</p>\"\n```\n\n## Other noteworthy features\n\n### Canvas support\n\njsdom includes support for using the [`canvas`](https://www.npmjs.com/package/canvas) package to extend any `<canvas>` elements with the canvas API. To make this work, you need to include `canvas` as a dependency in your project, as a peer of `jsdom`. If jsdom can find the `canvas` package, it will use it, but if it's not present, then `<canvas>` elements will behave like `<div>`s. Since jsdom v13, version 2.x of `canvas` is required; version 1.x is no longer supported.\n\n### Encoding sniffing\n\nIn addition to supplying a string, the `JSDOM` constructor can also be supplied binary data, in the form of a Node.js [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html) or a standard JavaScript binary data type like `ArrayBuffer`, `Uint8Array`, `DataView`, etc. When this is done, jsdom will [sniff the encoding](https://html.spec.whatwg.org/multipage/syntax.html#encoding-sniffing-algorithm) from the supplied bytes, scanning for `<meta charset>` tags just like a browser does.\n\nIf the supplied `contentType` option contains a `charset` parameter, that encoding will override the sniffed encoding—unless a UTF-8 or UTF-16 BOM is present, in which case those take precedence. (Again, this is just like a browser.)\n\nThis encoding sniffing also applies to `JSDOM.fromFile()` and `JSDOM.fromURL()`. In the latter case, any `Content-Type` headers sent with the response will take priority, in the same fashion as the constructor's `contentType` option.\n\nNote that in many cases supplying bytes in this fashion can be better than supplying a string. For example, if you attempt to use Node.js's `buffer.toString(\"utf-8\")` API, Node.js will not strip any leading BOMs. If you then give this string to jsdom, it will interpret it verbatim, leaving the BOM intact. But jsdom's binary data decoding code will strip leading BOMs, just like a browser; in such cases, supplying `buffer` directly will give the desired result.\n\n### Closing down a jsdom\n\nTimers in the jsdom (set by `window.setTimeout()` or `window.setInterval()`) will, by definition, execute code in the future in the context of the window. Since there is no way to execute code in the future without keeping the process alive, outstanding jsdom timers will keep your Node.js process alive. Similarly, since there is no way to execute code in the context of an object without keeping that object alive, outstanding jsdom timers will prevent garbage collection of the window on which they are scheduled.\n\nIf you want to be sure to shut down a jsdom window, use `window.close()`, which will terminate all running timers (and also remove any event listeners on the window and document).\n\n### Running jsdom inside a web browser\n\njsdom has some support for being run inside a web browser, using [browserify](https://browserify.org/). That is, inside a web browser, you can use a browserified jsdom to create an entirely self-contained set of plain JavaScript objects which look and act much like the browser's existing DOM objects, while being entirely independent of them. \"Virtual DOM\", indeed!\n\njsdom's primary target is still Node.js, and so we use language features that are only present in recent Node.js versions. Thus, older browsers will likely not work. (Even transpilation will not help: we use `Proxy`s extensively throughout the jsdom codebase.)\n\nNotably, jsdom works well inside a web worker. The original contributor, [@lawnsea](https://github.com/lawnsea/), who made this possible, has [published a paper](https://pdfs.semanticscholar.org/47f0/6bb6607a975500a30e9e52d7c9fbc0034e27.pdf) about his project which uses this capability.\n\nNot everything works perfectly when running jsdom inside a web browser. Sometimes that is because of fundamental limitations (such as not having filesystem access), but sometimes it is simply because we haven't spent enough time making the appropriate small tweaks. Bug reports are certainly welcome.\n\n### Debugging the DOM using Chrome DevTools\n\nIn Node.js you can debug programs using Chrome DevTools. See the [official documentation](https://nodejs.org/en/docs/inspector/) for how to get started.\n\nBy default jsdom elements are formatted as plain old JS objects in the console. To make it easier to debug, you can use [jsdom-devtools-formatter](https://github.com/jsdom/jsdom-devtools-formatter), which lets you inspect them like real DOM elements.\n\n## Caveats\n\n### Asynchronous script loading\n\nPeople often have trouble with asynchronous script loading when using jsdom. Many pages load scripts asynchronously, but there is no way to tell when they're done doing so, and thus when it's a good time to run your code and inspect the resulting DOM structure. This is a fundamental limitation; we cannot predict what scripts on the web page will do, and so cannot tell you when they are done loading more scripts.\n\nThis can be worked around in a few ways. The best way, if you control the page in question, is to use whatever mechanisms are given by the script loader to detect when loading is done. For example, if you're using a module loader like RequireJS, the code could look like:\n\n```js\n// On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () => {\n  console.log(\"ready to roll!\");\n};\n```\n\n```html\n<!-- Inside the HTML you supply to jsdom -->\n<script>\nrequirejs([\"entry-module\"], () => {\n  window.onModulesLoaded();\n});\n</script>\n```\n\nIf you do not control the page, you could try workarounds such as polling for the presence of a specific element.\n\nFor more details, see the discussion in [#640](https://github.com/jsdom/jsdom/issues/640), especially [@matthewkastor](https://github.com/matthewkastor)'s [insightful comment](https://github.com/jsdom/jsdom/issues/640#issuecomment-22216965).\n\n### Unimplemented parts of the web platform\n\nAlthough we enjoy adding new features to jsdom and keeping it up to date with the latest web specs, it has many missing APIs. Please feel free to file an issue for anything missing, but we're a small and busy team, so a pull request might work even better.\n\nSome features of jsdom are provided by our dependencies. Notable documentation in that regard includes the list of [supported CSS selectors](https://github.com/dperini/nwsapi/wiki/CSS-supported-selectors) for our CSS selector engine, [`nwsapi`](https://github.com/dperini/nwsapi).\n\nBeyond just features that we haven't gotten to yet, there are two major features that are currently outside the scope of jsdom. These are:\n\n- **Navigation**: the ability to change the global object, and all other objects, when clicking a link or assigning `location.href` or similar.\n- **Layout**: the ability to calculate where elements will be visually laid out as a result of CSS, which impacts methods like `getBoundingClientRects()` or properties like `offsetTop`.\n\nCurrently jsdom has dummy behaviors for some aspects of these features, such as sending a \"not implemented\" `\"jsdomError\"` to the virtual console for navigation, or returning zeros for many layout-related properties. Often you can work around these limitations in your code, e.g. by creating new `JSDOM` instances for each page you \"navigate\" to during a crawl, or using `Object.defineProperty()` to change what various layout-related getters and methods return.\n\nNote that other tools in the same space, such as PhantomJS, do support these features. On the wiki, we have a more complete writeup about [jsdom vs. PhantomJS](https://github.com/jsdom/jsdom/wiki/jsdom-vs.-PhantomJS).\n\n## Supporting jsdom\n\njsdom is a community-driven project maintained by a team of [volunteers](https://github.com/orgs/jsdom/people). You could support jsdom by:\n\n- [Getting professional support for jsdom](https://tidelift.com/subscription/pkg/npm-jsdom?utm_source=npm-jsdom&utm_medium=referral&utm_campaign=readme) as part of a Tidelift subscription. Tidelift helps making open source sustainable for us while giving teams assurances for maintenance, licensing, and security.\n- [Contributing](https://github.com/jsdom/jsdom/blob/master/Contributing.md) directly to the project.\n\n## Getting help\n\nIf you need help with jsdom, please feel free to use any of the following venues:\n\n- The [mailing list](https://groups.google.com/group/jsdom) (best for \"how do I\" questions)\n- The [issue tracker](https://github.com/jsdom/jsdom/issues) (best for bug reports)\n- The Matrix room: [#jsdom:matrix.org](https://matrix.to/#/#jsdom:matrix.org)\n",
    "93f312a7e5e399c152aa3ab3f04c87a4b17301e7": "---\ntitle: jsdom 中文文档\n---\n\n<h1 align=\"center\">\n    <img width=\"100\" height=\"100\" src=\"https://github.com/jsdom/jsdom/raw/master/logo.svg\" alt=\"\"><br>\n    jsdom\n</h1>\n\njsdom 是一个纯粹由 JavaScript 实现的一系列 Web 标准，特别是 WHATWG 组织制定的 [DOM](https://dom.spec.whatwg.org/) 和 [HTML](https://html.spec.whatwg.org/multipage/) 标准，用于在 Node.js 中使用。大体上来说，该项目的目标是模拟足够的 Web 浏览器子集，以便用于测试和挖掘真实世界的 Web 应用程序。\n\n最新版本的 jsdom 运行环境需要 Node.js v14 或者更高的版本。（jsdom v20 以下版本依旧可以在 Node.js 以前的版本使用，但是我们已经不支持维护了。）\n\n## 基本用法\n\n<!-- prettier-ignore-start -->\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n<!-- prettier-ignore-end -->\n\n为了使用 jsdom，主要用到 jsdom 主模块的一个命名导出的 `JSDOM` 构造函数。往构造器传递一个字符串，将会得到一个 `JSDOM` 构造实例对象，这个对象有很多实用的属性，特别是 `window` 对象：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); // \"Hello world\"\n```\n<!-- prettier-ignore-end -->\n\n（请注意，jsdom 会像浏览器一样解析您传递的 HTML，包括隐含的 `<html>`，`<head>` 和 `<body>` 标记。）\n\n生成的对象是 `JSDOM` 类的一个实例，其中包括 `window` 对象在内的许多有用的属性和方法。一般来说，它可以用来从“外部”对 jsdom 进行操作，而这些操作对于普通 DOM API 来说是不可能的。对于不需要任何功能的简单场景，我们推荐使用类似的编码模式\n\n<!-- prettier-ignore-start -->\n```js\nconst { window } = new JSDOM(`...`);\n// or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n<!-- prettier-ignore-end -->\n\n下面是关于 `JSDOM` 类所能做的一切的完整文档，在“`JSDOM` 对象 API”部分。\n\n## 定制 jsdom\n\n`JSDOM` 构造函数接受第二个参数，可以用以下方式定制您的 jsdom。\n\n### 简单选项\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(``, {\n  url: \"https://example.org/\",\n  referrer: \"https://example.com/\",\n  contentType: \"text/html\",\n  includeNodeLocations: true,\n  storageQuota: 10000000\n});\n```\n<!-- prettier-ignore-end -->\n\n- `url` 设置的值可以通过 `window.location`，`document.URL` 和 `document.documentURI` 来返回，并会影响文档中相关 URL 的解析以及获取子资源时使用的同源限制和 referrer。默认值为`\"about:blank\"`。\n- `referrer` 仅仅影响 `document.referrer` 的值。默认没有引用（即为空字符串）。\n- `contentType` 影响 `document.contentType` 的值，是按照 HTML 解析文档还是 XML 来解析。它的值如果不是 [HTML MIME 类型](https://mimesniff.spec.whatwg.org/#html-mime-type) 或 [XML MIME 类型](https://mimesniff.spec.whatwg.org/#xml-mime-type) 值的话将会抛出异常。默认值为`\"text/html\"`。如果存在 `charset` 参数，它会影响[二进制数据处理](#编码嗅探)。\n- `includeNodeLocations` 保留由 HTML 解析器生成的位置信息，允许您使用 `nodeLocation()` 方法（如下所述）检索它。它还能确保在 `<script>` 元素内运行的代码的异常堆栈跟踪中报告的行号是正确的。默认值为 `false` 以提供最佳性能，并且不能与 XML 内容类型一起使用，因为我们的 XML 解析器不支持位置信息。\n- `storageQuota` 是 `localStorage` 和 `sessionStorage` 使用的单独存储区域的代码单元的最大大小。尝试存储大于此限制的数据将导致抛出 `DOMException`。默认情况下，受 HTML 规范的启发，每个源设置为 5,000,000 个代码单元。\n\n请注意，`url` 和 `referrer` 在使用之前已经被规范化了，例如：如果你传入 `\"https:example.com\"`，jsdom 会自动规范化解释为 `\"https://example.com/\"`。如果你传递了一个不可解析的 URL，该调用将抛出错误。（URL 根据 [URL 标准](https://url.spec.whatwg.org/)进行分析和序列化。）\n\n### 执行脚本\n\njsdom 最强大的功能是它可以在 jsdom 中执行脚本。这些脚本可以修改页面的内容并访问 jsdom 实现的所有 Web 平台 API。\n\n但是，这在处理不可信内容时也非常危险。jsdom 沙箱并不是万无一失的，在 DOM 的 `<script>` 内部运行的代码如果足够深入，就可以访问 Node.js 环境，从而访问您的计算机。因此，默认情况下，执行嵌入在 HTML 中的脚本的功能是禁用的：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`);\n\n// 脚本默认将不会执行：\ndom.window.document.body.children.length === 1;\n```\n<!-- prettier-ignore-end -->\n\n要在页面内启用脚本，可以使用 `runScripts: \"dangerously\"` 选项：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<body>\n  <script>document.body.appendChild(document.createElement(\"hr\"));</script>\n</body>`, { runScripts: \"dangerously\" });\n\n// 脚本将执行并修改 DOM：\ndom.window.document.body.children.length === 2;\n```\n<!-- prettier-ignore-end -->\n\n我们再次强调只有在提供给 jsdom 的代码是你已知道是安全的才可使用它。如果您运行了任意用户提供的或 Internet 上的不可信的 Node.js 代码，可能会危及您的计算机。\n\n假如你想通过 `<script src=\"\">` 来执行外部脚本，你需要确保已经加载了它们。为此，请添加选项 `resources: \"usable\"` [如下所述](#加载子资源)。（出于此处讨论的原因，您可能还需要设置 `url` 选项。）\n\n除非 `runScripts` 设置为 `\"dangerously\"`，否则事件处理属性（如`<div onclick=\"\">`）也将受此选项控制不起作用。（但是，事件处理函数属性，比如 `div.onclick = ...`，将忽略 `runScripts` 参数并且会起作用。）\n\n如果您只是试图从“外部”执行脚本，而不是通过 `<script>` 元素和事件处理属性从“内部”运行，则可以使用 `runScripts: \"outside-only\"` 选项，这使得所有 JavaScript 规范提供的全局变量的新副本都可以安装在 `window` 上。 这包括诸如 `window.Array`、`window.Promise` 等等。值得注意的是，它还包括 `window.eval` 可以用来运行脚本，运行时将 jsdom 的 `window` 作为全局：\n\n<!-- prettier-ignore-start -->\n```js\nconst { window } = new JSDOM(``, { runScripts: \"outside-only\" });\n\nwindow.eval(`document.body.innerHTML = \"<p>Hello, world!</p>\";`);\nwindow.document.body.children.length === 1;\n```\n<!-- prettier-ignore-end -->\n\n由于性能原因，默认情况下会关闭此功能，但可以安全启用。\n\n（注意，默认配置下，不设置 `runScripts`，`window.Array`、`window.eval`等的值会与外部 Node.js 环境提供的值相同。即` window.eval === eval` 会成立，所以 `window.eval` 不会以有用的方式运行脚本。）\n\n我们强烈建议不要试图通过将 jsdom 和 Node 全局环境混合在一起（例如，通过执行 `global.window = dom.window`）来“执行脚本”，然后在 Node 全局环境中执行脚本或测试代码。相反，您应该像对待浏览器一样对待 jsdom，并使用 `window.eval` 或 `runScripts: \"dangerously\"` 来运行需要访问 jsdom 环境内的 DOM 的所有脚本和测试。例如，这可能需要创建一个 browserify 包作为 `<script>` 元素执行 - 就像在浏览器中一样。\n\n最后，对于高级用例，您可以使用 `dom.getInternalVMContext()` 方法，如下所述。\n\n### 假装成一个视觉浏览器\n\njsdom 没有渲染可视内容的能力，并且默认情况下会像无头浏览器一样工作。它通过 API（如 `document.hidden`）向网页提供提示，表明其内容不可见。\n\n当 `pretendToBeVisual` 选项设置为 true 时，jsdom 会假装它正在呈现并显示内容。它是这样做的：\n\n- 更改 `document.hidden` 以返回 `false` 而不是 `true`\n- 更改 `document.visibilityState` 以返回 `\"visible\"` 而不是 `\"prerender\"`\n- 启用 `window.requestAnimationFrame()` 和 `window.cancelAnimationFrame()` 方法，否则不存在\n\n<!-- prettier-ignore-start -->\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp => {\n  console.log(timestamp > 0);\n});\n```\n<!-- prettier-ignore-end -->\n\n请注意，jsdom 仍然[不做任何布局或渲染](#未实现的-web-平台部分)，因此这实际上只是假装为可视化，而不是实现真正的可视化 Web 浏览器将实现的部分。\n\n### 加载子资源\n\n#### 基础选项\n\n默认情况下，jsdom 不会加载任何子资源，如脚本，样式表，图像或 iframe。如果您希望 jsdom 加载这些资源，则可以传递 `resources: \"usable\"` 选项，该选项将加载所有可用资源。资源列表如下：\n\n- 通过 `<frame>` 和 `<iframe>` 加载 frame 和 iframe\n- 通过 `<link rel=\"stylesheet\">` 加载样式\n- 通过 `<script>` 加载脚本，但是前提是 `runScripts: \"dangerously\"` 设置了\n- 通过 `<img>` 加载图片，但是前提是 `canvas` npm 包已安装（详见下面的[支持 Canvas](#支持-canvas)）\n\n尝试加载资源时，请记住 `url` 选项的默认值是 `\"about:blank\"`，这意味着通过相对 URL 包含的任何资源都将无法加载。（针对 URL `about:blank` 解析 URL `/something` 的结果是一个错误。）因此，在这些情况下，您可能希望为 `url` 选项设置一个非默认值，或使用自动执行此操作的[便捷的 API](#便捷的-api) 之一。\n\n#### 高级配置\n\n要更全面地自定义 jsdom 的资源加载行为，可以将 `ResourceLoader` 类的实例作为 `resources` 选项值传递：\n\n<!-- prettier-ignore-start -->\n```js\nconst resourceLoader = new jsdom.ResourceLoader({\n  proxy: \"http://127.0.0.1:9001\",\n  strictSSL: false,\n  userAgent: \"Mellblomenator/9000\",\n});\nconst dom = new JSDOM(``, { resources: resourceLoader });\n```\n<!-- prettier-ignore-end -->\n\n`ResourceLoader` 构造函数的三个选项是：\n\n- `proxy` 是要使用的 HTTP 代理的地址。\n- `strictSSL` 可以设置为 false 以禁用 SSL 证书有效的要求。\n- `userAgent` 影响发送的 `User-Agent` 标头，从而影响 `navigator.userAgent` 的结果值。 它默认为 <code>\\`Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/${jsdomVersion}\\`</code>。\n\n您可以通过继承 `ResourceLoader` 并覆盖 `fetch()` 方法来进一步自定义资源获取。例如，覆盖指定 URL 返回的内容：\n\n<!-- prettier-ignore-start -->\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    // 重写此脚本的内容以执行一些不寻常的操作。\n    if (url === \"https://example.com/some-specific-script.js\") {\n      return Promise.resolve(Buffer.from(\"window.someGlobal = 5;\"));\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n<!-- prettier-ignore-end -->\n\njsdom 在遇到之前说到的“可用”资源时会调用自定义资源加载器的 `fetch()` 方法。该方法接受一个 URL 字符串，以及一些在调用 `super.fetch()` 时应透传的选项。它必须返回一个 Node.js 的 `Buffer` 对象的 promise，或者如果有意不加载资源则返回 `null`。一般来说，大多数情况下都希望像上面代码一样委托给 `super.fetch()`。\n\n可以在 `fetch()` 中收到的选项之一是获取资源的元素（如果适用）。\n\n<!-- prettier-ignore-start -->\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    if (options.element) {\n      console.log(`Element ${options.element.localName} is requesting the url ${url}`);\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n<!-- prettier-ignore-end -->\n\n### 虚拟控制台\n\n像网页浏览器一样，jsdom 也具有“控制台”的概念。通过在文档内执行的脚本以及来自 jsdom 本身实现的信息和记录会从页面直接发送过来。我们将用户可控制的控制台称为“虚拟控制台”，以便将其与 Node.js `console` API 和页面内部的 `window.console` API 区分开来。\n\n默认情况下，`JSDOM` 构造函数将返回一个具有虚拟控制台的实例，该虚拟控制台将其所有输出转发到 Node.js 控制台。为了创建自己的虚拟控制台并将其传递给 jsdom，可以通过执行下面代码来覆盖此默认值\n\n<!-- prettier-ignore-start -->\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n<!-- prettier-ignore-end -->\n\n这样的代码将创建一个没有任何行为的虚拟控制台。您可以为所有可能的控制台方法添加事件侦听器来为其提供行为：\n\n<!-- prettier-ignore-start -->\n```js\nvirtualConsole.on(\"error\", () => { ... });\nvirtualConsole.on(\"warn\", () => { ... });\nvirtualConsole.on(\"info\", () => { ... });\nvirtualConsole.on(\"dir\", () => { ... });\n// ... etc. See https://console.spec.whatwg.org/#logging\n```\n<!-- prettier-ignore-end -->\n\n（请注意，最好在调用 `new JSDOM()` 之前设置这些事件侦听器，因为在解析期间可能会发生错误或控制台调用脚本错误。）\n\n如果你只是想将虚拟控制台输出重定向到另一个控制台，比如默认的 Node.js，你可以这样做\n\n<!-- prettier-ignore-start -->\n```js\nvirtualConsole.sendTo(console);\n```\n<!-- prettier-ignore-end -->\n\n还有一个特殊的事件，`\"jsdomError\"`，它的触发将通过错误对象来记录 jsdom 本身的错误。这与错误消息在 Web 浏览器控制台中的显示方式类似，即使它们不是由 console.error 输出的。到目前为止，错误会按照下面的方式输出：\n\n- 加载或解析子资源时出错（脚本，样式表，frames 和 iframe）\n- 不是由 window `onerror` 事件处理程序处理的脚本执行错误，它将会返回 `true` 或调用 `event.preventDefault()`\n- 由于调用 jsdom 没有实现的方法而导致的错误，例如 `window.alert`，兼容性的 Web 浏览器都实现了这些方法\n\n如果您使用 `sendTo(c)` 将错误发送给 `c`，则默认情况下，它将使用来自`\"jsdomError\"`事件的信息调用 `c.error(errorStack[, errorDetail])`。如果您希望保持事件与方法调用的严格的一对一映射，并且可能自己处理`\"jsdomError\"`，那么您可以执行\n\n<!-- prettier-ignore-start -->\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n<!-- prettier-ignore-end -->\n\n### Cookie 容器\n\n像网页浏览器一样，jsdom 也具有 cookie 容器的概念，存储 HTTP cookie。在文档的同一个域上一个 URL，并且没有标记为 HTTP-only 的 cookies，可以通过`document.cookie` API 来访问。此外，cookie 容器中的所有 cookie 都会影响子资源的加载。\n\n默认情况下，`JSDOM` 构造函数将返回一个带有空 cookie 的实例。要创建自己的 cookie 容器并将其传递给 jsdom，可以通过以下代码来覆盖默认值\n\n<!-- prettier-ignore-start -->\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n<!-- prettier-ignore-end -->\n\n如果您想要在多个 jsdom 中共享同一个 cookie 容器，或者提前使用特定的值来填充 cookie 容器，这将非常有用。\n\nCookie jar 由 [tough-cookie](https://www.npmjs.com/package/tough-cookie) 包提供。`jsdom.CookieJar`构造函数是 tough-cookie cookie 容器的子类，并且默认设置了 `looseMode：true` 选项，因为它[更符合浏览器的行为方式](https://github.com/whatwg/html/issues/804)。如果您想自己使用 tough-cookie 的方法和类，则可以使用 `jsdom.toughCookie` 模块导出来访问使用 jsdom 打包的 tough-cookie 模块实例。\n\n### 在解析之前进行干预\n\njsdom 允许您在很早的时候介入创建 jsdom：创建 Window 和 Document 对象之后，但在解析任何 HTML 并使用节点填充文档之前：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<p>Hello</p>`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () => { /* ... */ };\n  }\n});\n```\n<!-- prettier-ignore-end -->\n\n如果您想以某种方式修改环境，例如为 jsdom 不支持的 Web 平台 API 添加 shim，这将特别有用。\n\n## `JSDOM` object API\n\n一旦你构建了一个 `JSDOM` 对象，它将具有以下有用的功能：\n\n### Properties\n\n`window` 属性: `window` 对象的 key 从 `Window` 对象检索而来。\n\n`virtualConsole` 和 `cookieJar`：可以传入或者使用默认值。\n\n### 通过 `serialize()` 序列化 document\n\n`serialize()` 方法将返回文档的 [HTML 序列化](https://html.spec.whatwg.org/#html-fragment-serialisation-algorithm)，包括 doctype：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(`<!DOCTYPE html>hello`);\n\ndom.serialize() === \"<!DOCTYPE html><html><head></head><body>hello</body></html>\";\n\n// 对比:\ndom.window.document.documentElement.outerHTML === \"<html><head></head><body>hello</body></html>\";\n```\n<!-- prettier-ignore-end -->\n\n### 通过 `nodeLocation(node)` 获取节点的源位置信息\n\n`nodeLocation()`方法将查找 DOM 节点在源文档中的位置，并返回节点的 [parse5 位置信息](https://www.npmjs.com/package/parse5#options-locationinfo)：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM(\n  `<p>Hello\n    <img src=\"foo.jpg\">\n  </p>`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; // implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   // null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      // { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); // { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    // { startOffset: 13, endOffset: 32 }\n```\n<!-- prettier-ignore-end -->\n\n请注意，只有设置了 `includeNodeLocations` 选项才能使用此功能；由于性能原因这个选项默认为关闭。\n\n### 使用 `getInternalVMContext()` 与 Node.js `vm` 模块交互\n\nNode.js 的内置 [`vm`](https://nodejs.org/api/vm.html) 模块是 jsdom 脚本运行魔法的基础。一些高级用例，例如预编译脚本然后多次运行，可以通过直接使用 `vm` 模块和 jsdom 创建的 `Window` 实现。\n\n可以使用 `getInternalVMContext()` 方法获取与 `vm` API 一起使用的[上下文化的全局对象](https://nodejs.org/api/vm.html#vm_what_does_it_mean_to_contextify_an_object)：\n\n<!-- prettier-ignore-start -->\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst script = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\nconst vmContext = dom.getInternalVMContext();\n\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\n\nconsole.assert(dom.window.ran === 3);\n```\n<!-- prettier-ignore-end -->\n\n这是高级功能，除非您有特殊的需求，否则我们建议坚持使用普通的 DOM API（如 `window.eval()` 或 `document.createElement(\"script\")`）。\n\n请注意，如果在没有设置 `runScripts` 的情况下创建了 `JSDOM` 实例，或者如果您 [在 Web 浏览器中使用 jsdom](#在-web-浏览器中运行-jsdom)，此方法将抛出异常。\n\n### 通过 `reconfigure(settings)` 重新配置 jsdom\n\n`window.top` 属性在规范中被标记为 `[Unforgeable]`，这意味着它是一个不可配置的私有属性，因此在 jsdom 内运行的普通代码是不能覆盖或隐藏它，即使使用 `Object.defineProperty`。\n\n同样，目前在 jsdom 中是不能够处理导航相关信息的（比如设置 `window.location.href = \"https://example.com/\"`）；这样做会导致在虚拟控制台报 `\"jsdomError\"` 错误，说明此功能未实现，并且没有任何变化：也将不会有新的 `Window` 或 `Document` 对象，并且现有 `window` 的 `location` 对象仍保持当前所有相同的属性值。\n\n但是，如果您从 jsdom 窗口之外进行操作，例如在一些创建 jsdom 的测试框架中，可以使用特殊的 `reconfigure()` 方法覆盖其中的一个或两个：\n\n<!-- prettier-ignore-start -->\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({\n  windowTop: myFakeTopForTesting,\n  url: \"https://example.com/\",\n});\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https://example.com/\";\n```\n<!-- prettier-ignore-end -->\n\n请注意，更改 jsdom 的 URL 将影响所有返回当前 document URL 的 API，例如 `window.location`、`document.URL` 和 `document.documentURI `，以及文档中相对 URL 的解析以及同源检查和提取子资源时使用的来源。但是，它不会执行导航到该 URL 的内容；DOM 的内容将保持不变，并且不会创建 `Window`，`Document`等新的实例。\n\n## 便捷的 API\n\n### `fromURL()`\n\n除了 `JSDOM` 构造函数本身之外，jsdom 还提供了一个返回 Promise 的工厂方法，用于通过 URL 构建一个 jsdom 实例：\n\n<!-- prettier-ignore-start -->\n```js\nJSDOM.fromURL(\"https://example.com/\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n<!-- prettier-ignore-end -->\n\n如果 URL 有效且请求成功，则 `onFullfilled` 回调执行并返回 `JSDOM` 实例。任何 URL 重定向都将遵循其最终目的地。\n\n`fromURL()` 提供的选项与提供给 `JSDOM` 构造函数的选项类似，但具有以下额外的限制和后果：\n\n- `url` 和 `contentType` 参数不能被提供。\n- `referrer` 选项用作初始请求的 HTTP `Referer` 请求头。\n- `resources` 选项也会影响初始请求；这很有用，例如，如果您想配置代理（见上文）。\n- 生成的 jsdom 的 URL、内容类型和来源是由响应来决定。\n- 任何通过 HTTP `Set-Cookie` 响应头设置的 cookie 都存储在 jsdom 的 cookie 容器中。同样，已提供的 cookie 容器中的任何 cookie 都会作为 HTTP `Cookie` 请求头发送。\n\n### `fromFile()`\n\n与 `fromURL()` 类似，jsdom 还提供了一个 `fromFile()` 工厂方法，用于从文件名构建 jsdom：\n\n<!-- prettier-ignore-start -->\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n<!-- prettier-ignore-end -->\n\n如果可以打开给定的文件，则 `onFullfilled` 回调执行并返回 `JSDOM` 实例。和 Node.js API 一样，文件名是相对于当前工作目录的。\n\n`fromFile()` 提供的选项与提供给 `JSDOM` 构造函数的选项相似，但具有以下额外的默认值：\n\n- `url` 选项将默认为给定文件名相对应的文件 URL，而不是 `\"about：blank\"`。\n- 假如给定的文件名是以 `.xht`、`.xhtml` 或者 `.xml` 为后缀的话，`contentType` 选项默认为 `\"application/xhtml+xml\"`；反之为 `\"text/html\"`。\n\n### `fragment()`\n\n对于最简单的情况，你可能不需要一个完整的 `JSDOM` 实例及其所有相关的功能。您甚至可能不需要 `Window` 或 `Document`！相反，你只需要解析一些 HTML 片段，并获得一个你可以操作的 DOM 对象。为此，我们提供了 `fragment()`，它可以从给定的字符串中创建一个` DocumentFragment`：\n\n<!-- prettier-ignore-start -->\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p><p><strong>Hi!</strong>`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent === \"Hi!\";\n// etc.\n```\n<!-- prettier-ignore-end -->\n\n`frag` 是 [`DocumentFragment`](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment) 的实例对象，其内容是通过提供的字符串解析创建的。解析是通过使用 `<template>` 元素完成的，因此您可以在其中包含任何元素（包括具有奇怪解析规则的元素，如 `<td>`）。还需要注意的是，生成的 `DocumentFragment` 不会有[关联的浏览上下文](https://html.spec.whatwg.org/multipage/#concept-document-bc)：即元素的 `ownerDocument` 将有一个空的 `defaultView` 属性，资源不会加载，等等。\n\n`fragment()` 工厂函数的所有调用结果的 `DocumentFragments` 实例都会共享相同的 `Document`。这允许多次调用 `fragment()` 而没有额外的开销。但这也意味着对 `fragment()` 的调用不能用任何选项自定义。\n\n请注意，对 `DocumentFragments` 的序列化并不像使用 `JSDOM` 对象那样容易。如果你需要序列化你的 DOM ，你应该直接使用 `JSDOM` 构造函数。但对于包含单个元素的片段的特殊情况，通过常规方法就很容易做到。\n\n<!-- prettier-ignore-start -->\n```js\nconst frag = JSDOM.fragment(`<p>Hello</p>`);\nconsole.log(frag.firstChild.outerHTML); // logs \"<p>Hello</p>\"\n```\n<!-- prettier-ignore-end -->\n\n## 其他值得注意的功能\n\n### 支持 Canvas\n\njsdom 支持使用 [`canvas`](https://www.npmjs.com/package/canvas) 包来扩展任何使用 canvas API 的 `<canvas>` 元素。为了做到这一点，您需要将 `canvas` 作为依赖项加入到您的项目中，和 `jsdom` 包并列。如果 jsdom 可以找到 `canvas` 包，它将使用它，但是如果它不存在，那么 `<canvas>` 元素的行为就像 `<div>` 一样。从 jsdom v13 开始，需要 `canvas` 的 2.x 版本；不再支持 1.x 版。\n\n### 编码嗅探\n\n除了提供一个字符串外，`JSDOM` 构造函数还支持 Node.js [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)或标准 JavaScript 二进制数据类型（如 `ArrayBuffer`，`Uint8Array`，`DataView` 等）的形式提供二进制数据。当完成后，jsdom 将就像浏览器一样从提供的字节进行[嗅探编码](https://html.spec.whatwg.org/multipage/syntax.html#encoding-sniffing-algorithm)，扫描 `<meta charset>` 标签。\n\n如果提供的 `contentType` 选项包含 `charset` 参数，则该编码将覆盖嗅探的编码 - 除非存在 UTF-8 或 UTF-16 BOM，在这种情况下嗅探的编码优先。（同样就像浏览器。）\n\n这种编码嗅探也适用于 `JSDOM.fromFile()` 和 `JSDOM.fromURL()`。在后一种情况下，就像在浏览器中一样，任何与响应一起发送的 `Content-Type` 头信息优先级更高，与构造函数的 `contentType` 选项的方式相同。\n\n请注意，在许多情况下，提供字节这种方式可能比提供字符串更好。例如，如果您试图使用 Node.js 的 `buffer.toString('utf-8')` API，则 Node.js 将不会去除任何前导 BOM。如果您将此字符串提供给 jsdom，它会逐字解释，从而使 BOM 保持不变。但 jsdom 的二进制数据解码代码将剥离前导的 BOM，就像浏览器一样；在这种情况下，直接提供 `buffer` 将会得到想要的结果。\n\n### 关闭 jsdom\n\njsdom 中定义的定时器（通过 `window.setTimeout()` 或 `window.setInterval()` 设置）将在 window 上下文中执行代码。由于进程在不活跃的情况下无法执行未来的定时器代码，所以卓越的 jsdom 定时器将保持您的 Node.js 进程处于活动状态。同样，对象不活跃的情况下也没有办法在对象的上下文中执行代码，卓越的 jsdom 定时器将阻止垃圾回收调度它们的 window。\n\n如果你想确保关闭 jsdom 窗口，使用 `window.close()`，它将终止所有正在运行的定时器（并且还会删除 `window` 和 `document` 上的任何事件监听器）。\n\n### 在 Web 浏览器中运行 jsdom\n\n使用 [browserify](http://browserify.org/) 模块，jsdom 某些方面也支持在 Web 浏览器中运行。也就是说，在 Web 浏览器中，您可以使用被 `browserify` 模块编译过的 jsdom 去创建完全独立的普通 JavaScript 对象集，其外观和行为与浏览器的现有 DOM 对象非常相似，但完全独立于它们，也就是“虚拟 DOM”！\n\njsdom 的主要目标对象仍然是 Node.js，因此我们使用仅存在于最新 Node.js 版本中的语言特性功能。因此，在旧版浏览器可能无法正常工作。（即使编译也不会有多大帮助：我们在整个 jsdom 代码库中广泛使用 `Proxy`。）\n\n值得注意的是，jsdom 在 Web Worker 中能很好的运行。项目的开发者 [@lawnsea](https://github.com/lawnsea/) 使这一功能点成为可能，他发表了一篇关于他的[项目的论文](https://pdfs.semanticscholar.org/47f0/6bb6607a975500a30e9e52d7c9fbc0034e27.pdf)，该论文就使用了这种能力。\n\n在 Web 浏览器中运行 jsdom 时，并非所有的工作都完美。有些情况下，这是由于基础的条件限制（比如没有文件系统访问），但有些情况下也是因为我们没有花足够的时间去进行适当的小调整。欢迎大家来提 bug。\n\n### 使用 Chrome 开发者工具调试 DOM\n\n可以使用 Chrome 开发者工具来调试 Node.js 程序。请参阅[官方文档](https://nodejs.org/en/docs/inspector/)了解如何使用。\n\n默认情况下，jsdom 元素在控制台中被格式化为普通的旧 JS 对象。为了便于调试，可以使用[jsdom-devtools-formatter](https://github.com/jsdom/jsdom-devtools-formatter)，它可以让你像真正的 DOM 元素一样调试它们。\n\n## 注意事项\n\n### 异步脚本加载\n\n使用 jsdom 时，开发者在加载异步脚本时经常遇到麻烦。许多页面异步加载脚本，但无法分辨脚本什么时候完成，因此无法知道何时是运行代码并检查生成的 DOM 结构的好时机。这是一个基本的限制；我们无法预测网页上的哪些脚本会做什么，因此无法告诉您脚本何时加载完毕。\n\n这个问题可以通过几种方法来解决。如果您能控制页面逻辑，最好的方法是使用脚本加载器提供的机制来检测何时加载完成。例如，如果您使用像 RequireJS 这样的模块加载器，代码可能如下所示：\n\n<!-- prettier-ignore-start -->\n```js\n// On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () => {\n  console.log(\"ready to roll!\");\n};\n```\n<!-- prettier-ignore-end -->\n\n<!-- prettier-ignore-start -->\n```html\n<!-- Inside the HTML you supply to jsdom -->\n<script>\nrequirejs([\"entry-module\"], () => {\n  window.onModulesLoaded();\n});\n</script>\n```\n<!-- prettier-ignore-end -->\n\n如果您不能控制该页面，则可以尝试其他解决方法，例如轮询检查特定元素是否存在。\n\n有关更多详细信息，请查看[#640](https://github.com/tmpvar/jsdom/issues/640)中的讨论，尤其是 [@matthewkastor](https://github.com/matthewkastor) 的[深刻见解](https://github.com/tmpvar/jsdom/issues/640#issuecomment-22216965)。\n\n### 未实现的 Web 平台部分\n\n目前 jsdom 中有很多缺失的 API，尽管我们也想要在 jsdom 中添加新的功能并保持最新的 Web 规范。请随时为缺失的任何内容提交 issue，但我们是一个很小并且忙碌的团队，因此大家一起来提交 pull request 可能会更好。\n\njsdom 的一些特性是由我们的依赖项提供的。这方面值得注意的文档包括我们的 [CSS 选择器引擎](https://github.com/dperini/nwsapi/wiki/CSS-supported-selectors) [`nwsapi`](https://github.com/dperini/nwsapi)。\n\n除了我们尚未拥有的功能之外，还有两个主要功能目前超出了 jsdom 的范围。这些是：\n\n- **导航**：在点击链接或赋值 `location.href` 或类似操作时可以更改全局对象和所有其他的对象。\n- **布局**：计算 CSS 元素的视觉布局的能力，这会影响诸如 `getBoundingClientRects()` 或者诸如 `offsetTop` 之类的属性。\n\n目前，jsdom 对某些功能的某些方面具有虚拟行为，例如操作导航时向虚拟控制台发送“未实现的”`\"jsdomError\"`，或者为许多与布局相关的属性返回 0。您通常可以在代码中解决这些限制，例如通过在爬网过程中为每个页面创建新的 `JSDOM` 实例，或使用 `Object.defineProperty()` 更改各种与布局相关的 getter 和方法的返回值\n\n请注意，相同领域中的其他工具（如 PhantomJS）确实支持这些功能。在 wiki 上，我们有关于 [jsdom 与 PhantomJS 比较](https://github.com/jsdom/jsdom/wiki/jsdom-vs.-PhantomJS)的更完整的介绍。\n\n## 支持 jsdom\n\njsdom 是一个社区驱动的项目，由[志愿者](https://github.com/orgs/jsdom/people)团队维护。您可以通过以下方式支持 jsdom：\n\n- 在 Tidelift 订阅中[获得对 jsdom 的专业支持](https://tidelift.com/subscription/pkg/npm-jsdom?utm_source=npm-jsdom&utm_medium=referral&utm_campaign=readme)。Tidelift 帮助我们实现开源的可持续发展，同时为团队提供维护、许可和安全方面的保证。\n- 直接对项目[做贡献](https://github.com/jsdom/jsdom/blob/master/Contributing.md)。\n\n## 获取帮助\n\n如果您需要 jsdom 的帮助，请随时使用以下任何方式：\n\n- [邮件组](https://groups.google.com/group/jsdom)（最好以 “how do I” 的形式提问）\n- [提 issue](https://github.com/jsdom/jsdom/issues)（最好用来提 bug）\n- Matrix 房间：[#jsdom:matrix.org](https://matrix.to/#/#jsdom:matrix.org)\n\n---\n\n原文地址：[jsdom/jsdom: A JavaScript implementation of various web standards, for use with Node.js](https://github.com/jsdom/jsdom)\n\n此翻译由 [zjffun/translated-document](https://github.com/zjffun/translated-document) 提供，在 GitHub 上[完善此翻译](https://github.com/zjffun/translated-document/edit/main/files/zh-cn/github/jsdom.md)。\n"
  }
}
