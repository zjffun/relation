{
  "key": ":files\u002Fen-us\u002Fgithub\u002Fjsdom.md::files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
  "checkResults": [
    {
      "id": "fe74ki8box",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        1,
        10
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        1,
        10
      ]
    },
    {
      "id": "t9vunlc2ow",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        12,
        36
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        12,
        32
      ]
    },
    {
      "id": "3ranzfuz0s",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        38,
        40
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        34,
        36
      ]
    },
    {
      "id": "r9i99d54kn",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        42,
        60
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        38,
        60
      ]
    },
    {
      "id": "vzyegwzsny",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        62,
        107
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        63,
        108
      ]
    },
    {
      "id": "vwblmqxt25",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        109,
        127
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        110,
        126
      ]
    },
    {
      "id": "idi9x10wjb",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        129,
        138
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        128,
        136
      ]
    },
    {
      "id": "7xb1ewjj3n",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        140,
        179
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        138,
        172
      ]
    },
    {
      "id": "t5y5wuqa3r",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        181,
        194
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        174,
        186
      ]
    },
    {
      "id": "ea6f60kvqq",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        196,
        209
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        188,
        199
      ]
    },
    {
      "id": "ybnss7kddf",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        211,
        213
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        201,
        202
      ]
    },
    {
      "id": "em4dcsgkc4",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        215,
        219
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        204,
        206
      ]
    },
    {
      "id": "e7aeqpergw",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        221,
        232
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        208,
        216
      ]
    },
    {
      "id": "ajeqma5ol3",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        234,
        258
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        218,
        239
      ]
    },
    {
      "id": "64qdkf89yr",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        260,
        283
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        242,
        265
      ]
    },
    {
      "id": "1ra3p1aue5",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        285,
        305
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        267,
        286
      ]
    },
    {
      "id": "vqh2t7mn3d",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        307,
        307
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        289,
        289
      ]
    },
    {
      "id": "uayg0z40z3",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        309,
        329
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        291,
        309
      ]
    },
    {
      "id": "p4xpgv0bmi",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        331,
        346
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        311,
        325
      ]
    },
    {
      "id": "752wkngegk",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        348,
        369
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        328,
        348
      ]
    },
    {
      "id": "4lm42d0sdh",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        371,
        371
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        350,
        350
      ]
    },
    {
      "id": "5qc18pe68b",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        373,
        375
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        352,
        353
      ]
    },
    {
      "id": "yavrugpwm3",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        377,
        383
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        355,
        361
      ]
    },
    {
      "id": "a9u6d8d5w7",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        385,
        389
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        363,
        367
      ]
    },
    {
      "id": "baa6wckxei",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        391,
        399
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        369,
        377
      ]
    },
    {
      "id": "thsb4o1qc2",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        401,
        405
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        379,
        383
      ]
    },
    {
      "id": "nli4ddbv2b",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        407,
        407
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        385,
        385
      ]
    },
    {
      "id": "ae6a2ntrkf",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        409,
        434
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        387,
        409
      ]
    },
    {
      "id": "sga2cah9rz",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        436,
        450
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        411,
        424
      ]
    },
    {
      "id": "r01n8niztz",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        452,
        458
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        426,
        432
      ]
    },
    {
      "id": "4mn9f2gvuk",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        460,
        471
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        434,
        444
      ]
    },
    {
      "id": "skyly6vwpq",
      "fromRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
      "fromBaseDir": "",
      "fromRange": [
        473,
        479
      ],
      "toRev": "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118",
      "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
      "toBaseDir": "",
      "toRange": [
        446,
        451
      ]
    }
  ],
  "fromPath": "files\u002Fen-us\u002Fgithub\u002Fjsdom.md",
  "fromBaseDir": "",
  "toPath": "files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md",
  "toBaseDir": "",
  "fileContents": {
    "::files\u002Fen-us\u002Fgithub\u002Fjsdom.md": "\u003Ch1 align=\"center\"\u003E\n    \u003Cimg width=\"100\" height=\"100\" src=\"logo.svg\" alt=\"\"\u003E\u003Cbr\u003E\n    jsdom\n\u003C\u002Fh1\u003E\n\njsdom is a pure-JavaScript implementation of many web standards, notably the WHATWG [DOM](https:\u002F\u002Fdom.spec.whatwg.org\u002F) and [HTML](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002F) Standards, for use with Node.js. In general, the goal of the project is to emulate enough of a subset of a web browser to be useful for testing and scraping real-world web applications.\n\nThe latest versions of jsdom require Node.js v14 or newer. (Versions of jsdom below v20 still work with previous Node.js versions, but are unsupported.)\n\n## Basic usage\n\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n\nTo use jsdom, you will primarily use the `JSDOM` constructor, which is a named export of the jsdom main module. Pass the constructor a string. You will get back a `JSDOM` object, which has a number of useful properties, notably `window`:\n\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003E\u003Cp\u003EHello world\u003C\u002Fp\u003E`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); \u002F\u002F \"Hello world\"\n```\n\n(Note that jsdom will parse the HTML you pass it just like a browser does, including implied `\u003Chtml\u003E`, `\u003Chead\u003E`, and `\u003Cbody\u003E` tags.)\n\nThe resulting object is an instance of the `JSDOM` class, which contains a number of useful properties and methods besides `window`. In general, it can be used to act on the jsdom from the \"outside,\" doing things that are not possible with the normal DOM APIs. For simple cases, where you don't need any of this functionality, we recommend a coding pattern like\n\n```js\nconst { window } = new JSDOM(`...`);\n\u002F\u002F or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n\nFull documentation on everything you can do with the `JSDOM` class is below, in the section \"`JSDOM` Object API\".\n\n## Customizing jsdom\n\nThe `JSDOM` constructor accepts a second parameter which can be used to customize your jsdom in the following ways.\n\n### Simple options\n\n```js\nconst dom = new JSDOM(``, {\n  url: \"https:\u002F\u002Fexample.org\u002F\",\n  referrer: \"https:\u002F\u002Fexample.com\u002F\",\n  contentType: \"text\u002Fhtml\",\n  includeNodeLocations: true,\n  storageQuota: 10000000\n});\n```\n\n- `url` sets the value returned by `window.location`, `document.URL`, and `document.documentURI`, and affects things like resolution of relative URLs within the document and the same-origin restrictions and referrer used while fetching subresources. It defaults to `\"about:blank\"`.\n- `referrer` just affects the value read from `document.referrer`. It defaults to no referrer (which reflects as the empty string).\n- `contentType` affects the value read from `document.contentType`, as well as how the document is parsed: as HTML or as XML. Values that are not a [HTML mime type](https:\u002F\u002Fmimesniff.spec.whatwg.org\u002F#html-mime-type) or an [XML mime type](https:\u002F\u002Fmimesniff.spec.whatwg.org\u002F#xml-mime-type) will throw. It defaults to `\"text\u002Fhtml\"`. If a `charset` parameter is present, it can affect [binary data processing](#encoding-sniffing).\n- `includeNodeLocations` preserves the location info produced by the HTML parser, allowing you to retrieve it with the `nodeLocation()` method (described below). It also ensures that line numbers reported in exception stack traces for code running inside `\u003Cscript\u003E` elements are correct. It defaults to `false` to give the best performance, and cannot be used with an XML content type since our XML parser does not support location info.\n- `storageQuota` is the maximum size in code units for the separate storage areas used by `localStorage` and `sessionStorage`. Attempts to store data larger than this limit will cause a `DOMException` to be thrown. By default, it is set to 5,000,000 code units per origin, as inspired by the HTML specification.\n\nNote that both `url` and `referrer` are canonicalized before they're used, so e.g. if you pass in `\"https:example.com\"`, jsdom will interpret that as if you had given `\"https:\u002F\u002Fexample.com\u002F\"`. If you pass an unparseable URL, the call will throw. (URLs are parsed and serialized according to the [URL Standard](https:\u002F\u002Furl.spec.whatwg.org\u002F).)\n\n### Executing scripts\n\njsdom's most powerful ability is that it can execute scripts inside the jsdom. These scripts can modify the content of the page and access all the web platform APIs jsdom implements.\n\nHowever, this is also highly dangerous when dealing with untrusted content. The jsdom sandbox is not foolproof, and code running inside the DOM's `\u003Cscript\u003E`s can, if it tries hard enough, get access to the Node.js environment, and thus to your machine. As such, the ability to execute scripts embedded in the HTML is disabled by default:\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`);\n\n\u002F\u002F The script will not be executed, by default:\ndom.window.document.body.children.length === 1;\n```\n\nTo enable executing scripts inside the page, you can use the `runScripts: \"dangerously\"` option:\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`, { runScripts: \"dangerously\" });\n\n\u002F\u002F The script will be executed and modify the DOM:\ndom.window.document.body.children.length === 2;\n```\n\nAgain we emphasize to only use this when feeding jsdom code you know is safe. If you use it on arbitrary user-supplied code, or code from the Internet, you are effectively running untrusted Node.js code, and your machine could be compromised.\n\nIf you want to execute _external_ scripts, included via `\u003Cscript src=\"\"\u003E`, you'll also need to ensure that they load them. To do this, add the option `resources: \"usable\"` [as described below](#loading-subresources). (You'll likely also want to set the `url` option, for the reasons discussed there.)\n\nEvent handler attributes, like `\u003Cdiv onclick=\"\"\u003E`, are also governed by this setting; they will not function unless `runScripts` is set to `\"dangerously\"`. (However, event handler _properties_, like `div.onclick = ...`, will function regardless of `runScripts`.)\n\nIf you are simply trying to execute script \"from the outside\", instead of letting `\u003Cscript\u003E` elements and event handlers attributes run \"from the inside\", you can use the `runScripts: \"outside-only\"` option, which enables fresh copies of all the JavaScript spec-provided globals to be installed on `window`. This includes things like `window.Array`, `window.Promise`, etc. It also, notably, includes `window.eval`, which allows running scripts, but with the jsdom `window` as the global:\n\n```js\nconst { window } = new JSDOM(``, { runScripts: \"outside-only\" });\n\nwindow.eval(`document.body.innerHTML = \"\u003Cp\u003EHello, world!\u003C\u002Fp\u003E\";`);\nwindow.document.body.children.length === 1;\n```\n\nThis is turned off by default for performance reasons, but is safe to enable.\n\n(Note that in the default configuration, without setting `runScripts`, the values of `window.Array`, `window.eval`, etc. will be the same as those provided by the outer Node.js environment. That is, `window.eval === eval` will hold, so `window.eval` will not run scripts in a useful way.)\n\nWe strongly advise against trying to \"execute scripts\" by mashing together the jsdom and Node global environments (e.g. by doing `global.window = dom.window`), and then executing scripts or test code inside the Node global environment. Instead, you should treat jsdom like you would a browser, and run all scripts and tests that need access to a DOM inside the jsdom environment, using `window.eval` or `runScripts: \"dangerously\"`. This might require, for example, creating a browserify bundle to execute as a `\u003Cscript\u003E` element—just like you would in a browser.\n\nFinally, for advanced use cases you can use the `dom.getInternalVMContext()` method, documented below.\n\n### Pretending to be a visual browser\n\njsdom does not have the capability to render visual content, and will act like a headless browser by default. It provides hints to web pages through APIs such as `document.hidden` that their content is not visible.\n\nWhen the `pretendToBeVisual` option is set to `true`, jsdom will pretend that it is rendering and displaying content. It does this by:\n\n* Changing `document.hidden` to return `false` instead of `true`\n* Changing `document.visibilityState` to return `\"visible\"` instead of `\"prerender\"`\n* Enabling `window.requestAnimationFrame()` and `window.cancelAnimationFrame()` methods, which otherwise do not exist\n\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp =\u003E {\n  console.log(timestamp \u003E 0);\n});\n```\n\nNote that jsdom still [does not do any layout or rendering](#unimplemented-parts-of-the-web-platform), so this is really just about _pretending_ to be visual, not about implementing the parts of the platform a real, visual web browser would implement.\n\n### Loading subresources\n\n#### Basic options\n\nBy default, jsdom will not load any subresources such as scripts, stylesheets, images, or iframes. If you'd like jsdom to load such resources, you can pass the `resources: \"usable\"` option, which will load all usable resources. Those are:\n\n* Frames and iframes, via `\u003Cframe\u003E` and `\u003Ciframe\u003E`\n* Stylesheets, via `\u003Clink rel=\"stylesheet\"\u003E`\n* Scripts, via `\u003Cscript\u003E`, but only if `runScripts: \"dangerously\"` is also set\n* Images, via `\u003Cimg\u003E`, but only if the `canvas` npm package is also installed (see \"[Canvas Support](#canvas-support)\" below)\n\nWhen attempting to load resources, recall that the default value for the `url` option is `\"about:blank\"`, which means that any resources included via relative URLs will fail to load. (The result of trying to parse the URL `\u002Fsomething` against the URL `about:blank` is an error.) So, you'll likely want to set a non-default value for the `url` option in those cases, or use one of the [convenience APIs](#convenience-apis) that do so automatically.\n\n#### Advanced configuration\n\n_This resource loader system is new as of jsdom v12.0.0, and we'd love your feedback on whether it meets your needs and how easy it is to use. Please file an issue to discuss!_\n\nTo more fully customize jsdom's resource-loading behavior, you can pass an instance of the `ResourceLoader` class as the `resources` option value:\n\n```js\nconst resourceLoader = new jsdom.ResourceLoader({\n  proxy: \"http:\u002F\u002F127.0.0.1:9001\",\n  strictSSL: false,\n  userAgent: \"Mellblomenator\u002F9000\",\n});\nconst dom = new JSDOM(``, { resources: resourceLoader });\n```\n\nThe three options to the `ResourceLoader` constructor are:\n\n- `proxy` is the address of an HTTP proxy to be used.\n- `strictSSL` can be set to false to disable the requirement that SSL certificates be valid.\n- `userAgent` affects the `User-Agent` header sent, and thus the resulting value for `navigator.userAgent`. It defaults to \u003Ccode\u003E\\`Mozilla\u002F5.0 (${process.platform || \"unknown OS\"}) AppleWebKit\u002F537.36 (KHTML, like Gecko) jsdom\u002F${jsdomVersion}\\`\u003C\u002Fcode\u003E.\n\nYou can further customize resource fetching by subclassing `ResourceLoader` and overriding the `fetch()` method. For example, here is a version that only returns results for requests to a trusted origin:\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    \u002F\u002F Override the contents of this script to do something unusual.\n    if (url === \"https:\u002F\u002Fexample.com\u002Fsome-specific-script.js\") {\n      return Promise.resolve(Buffer.from(\"window.someGlobal = 5;\"));\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\njsdom will call your custom resource loader's `fetch()` method whenever it encounters a \"usable\" resource, per the above section. The method takes a URL string, as well as a few options which you should pass through unmodified if calling `super.fetch()`. It must return a promise for a Node.js `Buffer` object, or return `null` if the resource is intentionally not to be loaded. In general, most cases will want to delegate to `super.fetch()`, as shown.\n\nOne of the options you will receive in `fetch()` will be the element (if applicable) that is fetching a resource.\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    if (options.element) {\n      console.log(`Element ${options.element.localName} is requesting the url ${url}`);\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\n### Virtual consoles\n\nLike web browsers, jsdom has the concept of a \"console\". This records both information directly sent from the page, via scripts executing inside the document, as well as information from the jsdom implementation itself. We call the user-controllable console a \"virtual console\", to distinguish it from the Node.js `console` API and from the inside-the-page `window.console` API.\n\nBy default, the `JSDOM` constructor will return an instance with a virtual console that forwards all its output to the Node.js console. To create your own virtual console and pass it to jsdom, you can override this default by doing\n\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n\nCode like this will create a virtual console with no behavior. You can give it behavior by adding event listeners for all the possible console methods:\n\n```js\nvirtualConsole.on(\"error\", () =\u003E { ... });\nvirtualConsole.on(\"warn\", () =\u003E { ... });\nvirtualConsole.on(\"info\", () =\u003E { ... });\nvirtualConsole.on(\"dir\", () =\u003E { ... });\n\u002F\u002F ... etc. See https:\u002F\u002Fconsole.spec.whatwg.org\u002F#logging\n```\n\n(Note that it is probably best to set up these event listeners *before* calling `new JSDOM()`, since errors or console-invoking script might occur during parsing.)\n\nIf you simply want to redirect the virtual console output to another console, like the default Node.js one, you can do\n\n```js\nvirtualConsole.sendTo(console);\n```\n\nThere is also a special event, `\"jsdomError\"`, which will fire with error objects to report errors from jsdom itself. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by `console.error`. So far, the following errors are output this way:\n\n- Errors loading or parsing subresources (scripts, stylesheets, frames, and iframes)\n- Script execution errors that are not handled by a window `onerror` event handler that returns `true` or calls `event.preventDefault()`\n- Not-implemented errors resulting from calls to methods, like `window.alert`, which jsdom does not implement, but installs anyway for web compatibility\n\nIf you're using `sendTo(c)` to send errors to `c`, by default it will call `c.error(errorStack[, errorDetail])` with information from `\"jsdomError\"` events. If you'd prefer to maintain a strict one-to-one mapping of events to method calls, and perhaps handle `\"jsdomError\"`s yourself, then you can do\n\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n\n### Cookie jars\n\nLike web browsers, jsdom has the concept of a cookie jar, storing HTTP cookies. Cookies that have a URL on the same domain as the document, and are not marked HTTP-only, are accessible via the `document.cookie` API. Additionally, all cookies in the cookie jar will impact the fetching of subresources.\n\nBy default, the `JSDOM` constructor will return an instance with an empty cookie jar. To create your own cookie jar and pass it to jsdom, you can override this default by doing\n\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n\nThis is mostly useful if you want to share the same cookie jar among multiple jsdoms, or prime the cookie jar with certain values ahead of time.\n\nCookie jars are provided by the [tough-cookie](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Ftough-cookie) package. The `jsdom.CookieJar` constructor is a subclass of the tough-cookie cookie jar which by default sets the `looseMode: true` option, since that [matches better how browsers behave](https:\u002F\u002Fgithub.com\u002Fwhatwg\u002Fhtml\u002Fissues\u002F804). If you want to use tough-cookie's utilities and classes yourself, you can use the `jsdom.toughCookie` module export to get access to the tough-cookie module instance packaged with jsdom.\n\n### Intervening before parsing\n\njsdom allows you to intervene in the creation of a jsdom very early: after the `Window` and `Document` objects are created, but before any HTML is parsed to populate the document with nodes:\n\n```js\nconst dom = new JSDOM(`\u003Cp\u003EHello\u003C\u002Fp\u003E`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () =\u003E { \u002F* ... *\u002F };\n  }\n});\n```\n\nThis is especially useful if you are wanting to modify the environment in some way, for example adding shims for web platform APIs jsdom does not support.\n\n## `JSDOM` object API\n\nOnce you have constructed a `JSDOM` object, it will have the following useful capabilities:\n\n### Properties\n\nThe property `window` retrieves the `Window` object that was created for you.\n\nThe properties `virtualConsole` and `cookieJar` reflect the options you pass in, or the defaults created for you if nothing was passed in for those options.\n\n### Serializing the document with `serialize()`\n\nThe `serialize()` method will return the [HTML serialization](https:\u002F\u002Fhtml.spec.whatwg.org\u002F#html-fragment-serialisation-algorithm) of the document, including the doctype:\n\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003Ehello`);\n\ndom.serialize() === \"\u003C!DOCTYPE html\u003E\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n\n\u002F\u002F Contrast with:\ndom.window.document.documentElement.outerHTML === \"\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n```\n\n### Getting the source location of a node with `nodeLocation(node)`\n\nThe `nodeLocation()` method will find where a DOM node is within the source document, returning the [parse5 location info](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fparse5#options-locationinfo) for the node:\n\n```js\nconst dom = new JSDOM(\n  `\u003Cp\u003EHello\n    \u003Cimg src=\"foo.jpg\"\u003E\n  \u003C\u002Fp\u003E`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; \u002F\u002F implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   \u002F\u002F null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      \u002F\u002F { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); \u002F\u002F { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    \u002F\u002F { startOffset: 13, endOffset: 32 }\n```\n\nNote that this feature only works if you have set the `includeNodeLocations` option; node locations are off by default for performance reasons.\n\n### Interfacing with the Node.js `vm` module using `getInternalVMContext()`\n\nThe built-in [`vm`](https:\u002F\u002Fnodejs.org\u002Fapi\u002Fvm.html) module of Node.js is what underpins jsdom's script-running magic. Some advanced use cases, like pre-compiling a script and then running it multiple times, benefit from using the `vm` module directly with a jsdom-created `Window`.\n\nTo get access to the [contextified global object](https:\u002F\u002Fnodejs.org\u002Fapi\u002Fvm.html#vm_what_does_it_mean_to_contextify_an_object), suitable for use with the `vm` APIs, you can use the `getInternalVMContext()` method:\n\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst script = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\nconst vmContext = dom.getInternalVMContext();\n\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\n\nconsole.assert(dom.window.ran === 3);\n```\n\nThis is somewhat-advanced functionality, and we advise sticking to normal DOM APIs (such as `window.eval()` or `document.createElement(\"script\")`) unless you have very specific needs.\n\nNote that this method will throw an exception if the `JSDOM` instance was created without `runScripts` set, or if you are [using jsdom in a web browser](#running-jsdom-inside-a-web-browser).\n\n### Reconfiguring the jsdom with `reconfigure(settings)`\n\nThe `top` property on `window` is marked `[Unforgeable]` in the spec, meaning it is a non-configurable own property and thus cannot be overridden or shadowed by normal code running inside the jsdom, even using `Object.defineProperty`.\n\nSimilarly, at present jsdom does not handle navigation (such as setting `window.location.href = \"https:\u002F\u002Fexample.com\u002F\"`); doing so will cause the virtual console to emit a `\"jsdomError\"` explaining that this feature is not implemented, and nothing will change: there will be no new `Window` or `Document` object, and the existing `window`'s `location` object will still have all the same property values.\n\nHowever, if you're acting from outside the window, e.g. in some test framework that creates jsdoms, you can override one or both of these using the special `reconfigure()` method:\n\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({ windowTop: myFakeTopForTesting, url: \"https:\u002F\u002Fexample.com\u002F\" });\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https:\u002F\u002Fexample.com\u002F\";\n```\n\nNote that changing the jsdom's URL will impact all APIs that return the current document URL, such as `window.location`, `document.URL`, and `document.documentURI`, as well as the resolution of relative URLs within the document, and the same-origin checks and referrer used while fetching subresources. It will not, however, perform navigation to the contents of that URL; the contents of the DOM will remain unchanged, and no new instances of `Window`, `Document`, etc. will be created.\n\n## Convenience APIs\n\n### `fromURL()`\n\nIn addition to the `JSDOM` constructor itself, jsdom provides a promise-returning factory method for constructing a jsdom from a URL:\n\n```js\nJSDOM.fromURL(\"https:\u002F\u002Fexample.com\u002F\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the URL is valid and the request is successful. Any redirects will be followed to their ultimate destination.\n\nThe options provided to `fromURL()` are similar to those provided to the `JSDOM` constructor, with the following additional restrictions and consequences:\n\n- The `url` and `contentType` options cannot be provided.\n- The `referrer` option is used as the HTTP `Referer` request header of the initial request.\n- The `resources` option also affects the initial request; this is useful if you want to, for example, configure a proxy (see above).\n- The resulting jsdom's URL, content type, and referrer are determined from the response.\n- Any cookies set via HTTP `Set-Cookie` response headers are stored in the jsdom's cookie jar. Similarly, any cookies already in a supplied cookie jar are sent as HTTP `Cookie` request headers.\n\n### `fromFile()`\n\nSimilar to `fromURL()`, jsdom also provides a `fromFile()` factory method for constructing a jsdom from a filename:\n\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the given file can be opened. As usual in Node.js APIs, the filename is given relative to the current working directory.\n\nThe options provided to `fromFile()` are similar to those provided to the `JSDOM` constructor, with the following additional defaults:\n\n- The `url` option will default to a file URL corresponding to the given filename, instead of to `\"about:blank\"`.\n- The `contentType` option will default to `\"application\u002Fxhtml+xml\"` if the given filename ends in `.xht`, `.xhtml`, or `.xml`; otherwise it will continue to default to `\"text\u002Fhtml\"`.\n\n### `fragment()`\n\nFor the very simplest of cases, you might not need a whole `JSDOM` instance with all its associated power. You might not even need a `Window` or `Document`! Instead, you just need to parse some HTML, and get a DOM object you can manipulate. For that, we have `fragment()`, which creates a `DocumentFragment` from a given string:\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EHi!\u003C\u002Fstrong\u003E`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent === \"Hi!\";\n\u002F\u002F etc.\n```\n\nHere `frag` is a [`DocumentFragment`](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FDocumentFragment) instance, whose contents are created by parsing the provided string. The parsing is done using a `\u003Ctemplate\u003E` element, so you can include any element there (including ones with weird parsing rules like `\u003Ctd\u003E`). It's also important to note that the resulting `DocumentFragment` will not have [an associated browsing context](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002F#concept-document-bc): that is, elements' `ownerDocument` will have a null `defaultView` property, resources will not load, etc.\n\nAll invocations of the `fragment()` factory result in `DocumentFragment`s that share the same template owner `Document`. This allows many calls to `fragment()` with no extra overhead. But it also means that calls to `fragment()` cannot be customized with any options.\n\nNote that serialization is not as easy with `DocumentFragment`s as it is with full `JSDOM` objects. If you need to serialize your DOM, you should probably use the `JSDOM` constructor more directly. But for the special case of a fragment containing a single element, it's pretty easy to do through normal means:\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E`);\nconsole.log(frag.firstChild.outerHTML); \u002F\u002F logs \"\u003Cp\u003EHello\u003C\u002Fp\u003E\"\n```\n\n## Other noteworthy features\n\n### Canvas support\n\njsdom includes support for using the [`canvas`](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fcanvas) package to extend any `\u003Ccanvas\u003E` elements with the canvas API. To make this work, you need to include `canvas` as a dependency in your project, as a peer of `jsdom`. If jsdom can find the `canvas` package, it will use it, but if it's not present, then `\u003Ccanvas\u003E` elements will behave like `\u003Cdiv\u003E`s. Since jsdom v13, version 2.x of `canvas` is required; version 1.x is no longer supported.\n\n### Encoding sniffing\n\nIn addition to supplying a string, the `JSDOM` constructor can also be supplied binary data, in the form of a Node.js [`Buffer`](https:\u002F\u002Fnodejs.org\u002Fdocs\u002Flatest\u002Fapi\u002Fbuffer.html) or a standard JavaScript binary data type like `ArrayBuffer`, `Uint8Array`, `DataView`, etc. When this is done, jsdom will [sniff the encoding](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fsyntax.html#encoding-sniffing-algorithm) from the supplied bytes, scanning for `\u003Cmeta charset\u003E` tags just like a browser does.\n\nIf the supplied `contentType` option contains a `charset` parameter, that encoding will override the sniffed encoding—unless a UTF-8 or UTF-16 BOM is present, in which case those take precedence. (Again, this is just like a browser.)\n\nThis encoding sniffing also applies to `JSDOM.fromFile()` and `JSDOM.fromURL()`. In the latter case, any `Content-Type` headers sent with the response will take priority, in the same fashion as the constructor's `contentType` option.\n\nNote that in many cases supplying bytes in this fashion can be better than supplying a string. For example, if you attempt to use Node.js's `buffer.toString(\"utf-8\")` API, Node.js will not strip any leading BOMs. If you then give this string to jsdom, it will interpret it verbatim, leaving the BOM intact. But jsdom's binary data decoding code will strip leading BOMs, just like a browser; in such cases, supplying `buffer` directly will give the desired result.\n\n### Closing down a jsdom\n\nTimers in the jsdom (set by `window.setTimeout()` or `window.setInterval()`) will, by definition, execute code in the future in the context of the window. Since there is no way to execute code in the future without keeping the process alive, outstanding jsdom timers will keep your Node.js process alive. Similarly, since there is no way to execute code in the context of an object without keeping that object alive, outstanding jsdom timers will prevent garbage collection of the window on which they are scheduled.\n\nIf you want to be sure to shut down a jsdom window, use `window.close()`, which will terminate all running timers (and also remove any event listeners on the window and document).\n\n### Running jsdom inside a web browser\n\njsdom has some support for being run inside a web browser, using [browserify](https:\u002F\u002Fbrowserify.org\u002F). That is, inside a web browser, you can use a browserified jsdom to create an entirely self-contained set of plain JavaScript objects which look and act much like the browser's existing DOM objects, while being entirely independent of them. \"Virtual DOM\", indeed!\n\njsdom's primary target is still Node.js, and so we use language features that are only present in recent Node.js versions. Thus, older browsers will likely not work. (Even transpilation will not help: we use `Proxy`s extensively throughout the jsdom codebase.)\n\nNotably, jsdom works well inside a web worker. The original contributor, [@lawnsea](https:\u002F\u002Fgithub.com\u002Flawnsea\u002F), who made this possible, has [published a paper](https:\u002F\u002Fpdfs.semanticscholar.org\u002F47f0\u002F6bb6607a975500a30e9e52d7c9fbc0034e27.pdf) about his project which uses this capability.\n\nNot everything works perfectly when running jsdom inside a web browser. Sometimes that is because of fundamental limitations (such as not having filesystem access), but sometimes it is simply because we haven't spent enough time making the appropriate small tweaks. Bug reports are certainly welcome.\n\n### Debugging the DOM using Chrome DevTools\n\nIn Node.js you can debug programs using Chrome DevTools. See the [official documentation](https:\u002F\u002Fnodejs.org\u002Fen\u002Fdocs\u002Finspector\u002F) for how to get started.\n\nBy default jsdom elements are formatted as plain old JS objects in the console. To make it easier to debug, you can use [jsdom-devtools-formatter](https:\u002F\u002Fgithub.com\u002Fviddo\u002Fjsdom-devtools-formatter), which lets you inspect them like real DOM elements.\n\n## Caveats\n\n### Asynchronous script loading\n\nPeople often have trouble with asynchronous script loading when using jsdom. Many pages load scripts asynchronously, but there is no way to tell when they're done doing so, and thus when it's a good time to run your code and inspect the resulting DOM structure. This is a fundamental limitation; we cannot predict what scripts on the web page will do, and so cannot tell you when they are done loading more scripts.\n\nThis can be worked around in a few ways. The best way, if you control the page in question, is to use whatever mechanisms are given by the script loader to detect when loading is done. For example, if you're using a module loader like RequireJS, the code could look like:\n\n```js\n\u002F\u002F On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () =\u003E {\n  console.log(\"ready to roll!\");\n};\n```\n\n```html\n\u003C!-- Inside the HTML you supply to jsdom --\u003E\n\u003Cscript\u003E\nrequirejs([\"entry-module\"], () =\u003E {\n  window.onModulesLoaded();\n});\n\u003C\u002Fscript\u003E\n```\n\nIf you do not control the page, you could try workarounds such as polling for the presence of a specific element.\n\nFor more details, see the discussion in [#640](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fissues\u002F640), especially [@matthewkastor](https:\u002F\u002Fgithub.com\u002Fmatthewkastor)'s [insightful comment](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fissues\u002F640#issuecomment-22216965).\n\n### Unimplemented parts of the web platform\n\nAlthough we enjoy adding new features to jsdom and keeping it up to date with the latest web specs, it has many missing APIs. Please feel free to file an issue for anything missing, but we're a small and busy team, so a pull request might work even better.\n\nBeyond just features that we haven't gotten to yet, there are two major features that are currently outside the scope of jsdom. These are:\n\n- **Navigation**: the ability to change the global object, and all other objects, when clicking a link or assigning `location.href` or similar.\n- **Layout**: the ability to calculate where elements will be visually laid out as a result of CSS, which impacts methods like `getBoundingClientRects()` or properties like `offsetTop`.\n\nCurrently jsdom has dummy behaviors for some aspects of these features, such as sending a \"not implemented\" `\"jsdomError\"` to the virtual console for navigation, or returning zeros for many layout-related properties. Often you can work around these limitations in your code, e.g. by creating new `JSDOM` instances for each page you \"navigate\" to during a crawl, or using `Object.defineProperty()` to change what various layout-related getters and methods return.\n\nNote that other tools in the same space, such as PhantomJS, do support these features. On the wiki, we have a more complete writeup about [jsdom vs. PhantomJS](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fwiki\u002Fjsdom-vs.-PhantomJS).\n\n## Supporting jsdom\n\njsdom is a community-driven project maintained by a team of [volunteers](https:\u002F\u002Fgithub.com\u002Forgs\u002Fjsdom\u002Fpeople). You could support jsdom by:\n\n- [Getting professional support for jsdom](https:\u002F\u002Ftidelift.com\u002Fsubscription\u002Fpkg\u002Fnpm-jsdom?utm_source=npm-jsdom&utm_medium=referral&utm_campaign=readme) as part of a Tidelift subscription. Tidelift helps making open source sustainable for us while giving teams assurances for maintenance, licensing, and security.\n- [Contributing](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fblob\u002Fmaster\u002FContributing.md) directly to the project.\n\n## Getting help\n\nIf you need help with jsdom, please feel free to use any of the following venues:\n\n- The [mailing list](https:\u002F\u002Fgroups.google.com\u002Fgroup\u002Fjsdom) (best for \"how do I\" questions)\n- The [issue tracker](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fissues) (best for bug reports)\n- The Matrix room: [#jsdom:matrix.org](https:\u002F\u002Fmatrix.to\u002F#\u002F#jsdom:matrix.org)\n",
    "::files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md": "\u003Ch1 align=\"center\"\u003E\n    \u003Cimg width=\"100\" height=\"100\" src=\"https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fraw\u002Fmaster\u002Flogo.svg\" alt=\"\"\u003E\u003Cbr\u003E\n    jsdom\n\u003C\u002Fh1\u003E\n\njsdom 是一个纯粹由 JavaScript 实现的一系列 Web 标准，特别是 WHATWG 组织制定的 [DOM](https:\u002F\u002Fdom.spec.whatwg.org\u002F) 和 [HTML](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002F) 标准，用于在 Node.js 中使用。大体上来说，该项目的目标是模拟足够的 Web 浏览器子集，以便用于测试和挖掘真实世界的 Web 应用程序。\n\n最新版本的 jsdom 运行环境需要 Node.js v14 或者更高的版本。（jsdom v20 以下版本依旧可以在 Node.js 以前的版本使用，但是我们已经不支持维护了。）\n\n## 基本用法\n\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n\n为了使用 jsdom，主要用到 jsdom 主模块的一个命名导出的 `JSDOM` 构造函数。往构造器传递一个字符串，将会得到一个 `JSDOM` 构造实例对象，这个对象有很多实用的属性，特别是 `window` 对象：\n\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003E\u003Cp\u003EHello world\u003C\u002Fp\u003E`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); \u002F\u002F \"Hello world\"\n```\n\n（请注意，jsdom 会像浏览器一样解析您传递的 HTML，包括隐含的 `\u003Chtml\u003E`，`\u003Chead\u003E` 和 `\u003Cbody\u003E` 标记。）\n\n生成的对象是 `JSDOM` 类的一个实例，其中包括 `window` 对象在内的许多有用的属性和方法。一般来说，它可以用来从“外部”对 jsdom 进行操作，而这些操作对于普通 DOM API 来说是不可能的。对于不需要任何功能的简单场景，我们推荐使用类似的编码模式\n\n```js\nconst { window } = new JSDOM(`...`);\n\u002F\u002F or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n\n下面是关于 `JSDOM` 类所能做的一切的完整文档，在“`JSDOM` 对象 API”部分。\n\n## 定制 jsdom\n\n`JSDOM` 构造函数接受第二个参数，可以用以下方式定制您的 jsdom。\n\n### 简单选项\n\n```js\nconst dom = new JSDOM(``, {\n  url: \"https:\u002F\u002Fexample.org\u002F\",\n  referrer: \"https:\u002F\u002Fexample.com\u002F\",\n  contentType: \"text\u002Fhtml\",\n  includeNodeLocations: true,\n  storageQuota: 10000000\n});\n```\n\n- `url` 设置的值可以通过 `window.location`，`document.URL` 和 `document.documentURI` 来返回，并会影响文档中相关 URL 的解析以及获取子资源时使用的同源限制和 referrer。默认值为`\"about:blank\"`。\n- `referrer` 仅仅影响 `document.referrer` 的值。默认没有引用（即为空字符串）。\n- `contentType` 影响 `document.contentType` 的值，是按照 HTML 解析文档还是 XML 来解析。它的值如果不是 [HTML MIME 类型](https:\u002F\u002Fmimesniff.spec.whatwg.org\u002F#html-mime-type) 或 [XML MIME 类型](https:\u002F\u002Fmimesniff.spec.whatwg.org\u002F#xml-mime-type) 值的话将会抛出异常。默认值为`\"text\u002Fhtml\"`。如果存在 `charset` 参数，它会影响[二进制数据处理](#编码嗅探)。\n- `includeNodeLocations` 保留由 HTML 解析器生成的位置信息，允许您使用 `nodeLocation()` 方法（如下所述）检索它。它还能确保在 `\u003Cscript\u003E` 元素内运行的代码的异常堆栈跟踪中报告的行号是正确的。默认值为 `false` 以提供最佳性能，并且不能与 XML 内容类型一起使用，因为我们的 XML 解析器不支持位置信息。\n- `storageQuota` 是 `localStorage` 和 `sessionStorage` 使用的单独存储区域的代码单元的最大大小。尝试存储大于此限制的数据将导致抛出 `DOMException`。默认情况下，受 HTML 规范的启发，每个源设置为 5,000,000 个代码单元。\n\n请注意，`url` 和 `referrer` 在使用之前已经被规范化了，例如：如果你传入 `\"https:example.com\"`，jsdom 会自动规范化解释为 `\"https:\u002F\u002Fexample.com\u002F\"`。如果你传递了一个不可解析的 URL，该调用将抛出错误。（URL 根据 [URL 标准](https:\u002F\u002Furl.spec.whatwg.org\u002F)进行分析和序列化。）\n\n### 执行脚本\n\njsdom 最强大的功能是它可以在 jsdom 中执行脚本。这些脚本可以修改页面的内容并访问 jsdom 实现的所有 Web 平台 API。\n\n但是，这在处理不可信内容时也非常危险。jsdom 沙箱并不是万无一失的，在 DOM 的 `\u003Cscript\u003E` 内部运行的代码如果足够深入，就可以访问 Node.js 环境，从而访问您的计算机。因此，默认情况下，执行嵌入在 HTML 中的脚本的功能是禁用的：\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`);\n\n\u002F\u002F 脚本默认将不会执行：\ndom.window.document.body.children.length === 1;\n```\n\n要在页面内启用脚本，可以使用 `runScripts: \"dangerously\"` 选项：\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`, { runScripts: \"dangerously\" });\n\n\u002F\u002F 脚本将执行并修改 DOM：\ndom.window.document.body.children.length === 2;\n```\n\n我们再次强调只有在提供给 jsdom 的代码是你已知道是安全的才可使用它。如果您运行了任意用户提供的或 Internet 上的不可信的 Node.js 代码，可能会危及您的计算机。\n\n假如你想通过 `\u003Cscript src=\"\"\u003E` 来执行外部脚本，你需要确保已经加载了它们。为此，请添加选项 `resources: \"usable\"` [如下所述](#加载子资源)。（出于此处讨论的原因，您可能还需要设置 `url` 选项。）\n\n除非 `runScripts` 设置为 `\"dangerously\"`，否则事件处理属性（如`\u003Cdiv onclick=\"\"\u003E`）也将受此选项控制不起作用。（但是，事件处理函数属性，比如 `div.onclick = ...`，将忽略 `runScripts` 参数并且会起作用。）\n\n如果您只是试图从“外部”执行脚本，而不是通过 `\u003Cscript\u003E` 元素和事件处理属性从“内部”运行，则可以使用 `runScripts: \"outside-only\"` 选项，这使得所有 JavaScript 规范提供的全局变量的新副本都可以安装在 `window` 上。 这包括诸如 `window.Array`、`window.Promise` 等等。值得注意的是，它还包括 `window.eval` 可以用来运行脚本，运行时将 jsdom 的 `window` 作为全局：\n\n```js\nconst { window } = new JSDOM(``, { runScripts: \"outside-only\" });\n\nwindow.eval(`document.body.innerHTML = \"\u003Cp\u003EHello, world!\u003C\u002Fp\u003E\";`);\nwindow.document.body.children.length === 1;\n```\n\n由于性能原因，默认情况下会关闭此功能，但可以安全启用。\n\n（注意，默认配置下，不设置 `runScripts`，`window.Array`、`window.eval`等的值会与外部 Node.js 环境提供的值相同。即` window.eval === eval` 会成立，所以 `window.eval` 不会以有用的方式运行脚本。）\n\n我们强烈建议不要试图通过将 jsdom 和 Node 全局环境混合在一起（例如，通过执行 `global.window = dom.window`）来“执行脚本”，然后在 Node 全局环境中执行脚本或测试代码。相反，您应该像对待浏览器一样对待 jsdom，并使用 `window.eval` 或 `runScripts: \"dangerously\"` 来运行需要访问 jsdom 环境内的 DOM 的所有脚本和测试。例如，这可能需要创建一个 browserify 包作为 `\u003Cscript\u003E` 元素执行 - 就像在浏览器中一样。\n\n最后，对于高级用例，您可以使用 `dom.getInternalVMContext()` 方法，如下所述。\n\n### 假装成一个视觉浏览器\n\njsdom 没有渲染可视内容的能力，并且默认情况下会像无头浏览器一样工作。它通过 API（如 `document.hidden`）向网页提供提示，表明其内容不可见。\n\n当 `pretendToBeVisual` 选项设置为 true 时，jsdom 会假装它正在呈现并显示内容。它是这样做的：\n\n- 更改 `document.hidden` 以返回 `false` 而不是 `true`\n- 更改 `document.visibilityState` 以返回 `\"visible\"` 而不是 `\"prerender\"`\n- 启用 `window.requestAnimationFrame()` 和 `window.cancelAnimationFrame()` 方法，否则不存在\n\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp =\u003E {\n  console.log(timestamp \u003E 0);\n});\n```\n\n请注意，jsdom 仍然[不做任何布局或渲染](#未实现的-web-平台部分)，因此这实际上只是假装为可视化，而不是实现真正的可视化 Web 浏览器将实现的部分。\n\n### 加载子资源\n\n#### 基础选项\n\n默认情况下，jsdom 不会加载任何子资源，如脚本，样式表，图像或 iframe。如果您希望 jsdom 加载这些资源，则可以传递 `resources: \"usable\"` 选项，该选项将加载所有可用资源。资源列表如下：\n\n- 通过 `\u003Cframe\u003E` 和 `\u003Ciframe\u003E` 加载 frame 和 iframe\n- 通过 `\u003Clink rel=\"stylesheet\"\u003E` 加载样式\n- 通过 `\u003Cscript\u003E` 加载脚本，但是前提是 `runScripts: \"dangerously\"` 设置了\n- 通过 `\u003Cimg\u003E` 加载图片，但是前提是 `canvas` npm 包已安装（详见下面的[支持 Canvas](#支持-canvas)）\n\n尝试加载资源时，请记住 `url` 选项的默认值是 `\"about:blank\"`，这意味着通过相对 URL 包含的任何资源都将无法加载。（针对 URL `about:blank` 解析 URL `\u002Fsomething` 的结果是一个错误。）因此，在这些情况下，您可能希望为 `url` 选项设置一个非默认值，或使用自动执行此操作的[便捷的 API](#便捷的-api) 之一。\n\n#### 高级配置\n\n_这个资源加载器系统是 jsdom v12.0.0 的新系统，我们希望您能就它是否满足您的需求以及它的易用性提供反馈。请提 issue 进行讨论！_\n\n要更全面地自定义 jsdom 的资源加载行为，可以将 `ResourceLoader` 类的实例作为 `resources` 选项值传递：\n\n```js\nconst resourceLoader = new jsdom.ResourceLoader({\n  proxy: \"http:\u002F\u002F127.0.0.1:9001\",\n  strictSSL: false,\n  userAgent: \"Mellblomenator\u002F9000\",\n});\nconst dom = new JSDOM(``, { resources: resourceLoader });\n```\n\n`ResourceLoader` 构造函数的三个选项是：\n\n- `proxy` 是要使用的 HTTP 代理的地址。\n- `strictSSL` 可以设置为 false 以禁用 SSL 证书有效的要求。\n- `userAgent` 影响发送的 `User-Agent` 标头，从而影响 `navigator.userAgent` 的结果值。 它默认为 \u003Ccode\u003E\\`Mozilla\u002F5.0 (${process.platform || \"unknown OS\"}) AppleWebKit\u002F537.36 (KHTML, like Gecko) jsdom\u002F${jsdomVersion}\\`\u003C\u002Fcode\u003E。\n\n您可以通过继承 `ResourceLoader` 并覆盖 `fetch()` 方法来进一步自定义资源获取。 例如，指定资源返回的内容：\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    \u002F\u002F 重写此脚本的内容以执行一些不寻常的操作。\n    if (url === \"https:\u002F\u002Fexample.com\u002Fsome-specific-script.js\") {\n      return Promise.resolve(Buffer.from(\"window.someGlobal = 5;\"));\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\njsdom 在遇到之前说到的“可用”资源时会调用自定义资源加载器的 `fetch()` 方法。该方法接受一个 URL 字符串，以及一些在调用 `super.fetch()` 时应透传的选项。它必须返回一个  Node.js 的 `Buffer` 对象的 promise，或者如果有意不加载资源则返回 `null`。一般来说，大多数情况下都希望像上面代码一样委托给 `super.fetch()`。\n\n可以在 `fetch()` 中收到的选项之一是获取资源的元素（如果适用）。\n\n```js\nclass CustomResourceLoader extends jsdom.ResourceLoader {\n  fetch(url, options) {\n    if (options.element) {\n      console.log(`Element ${options.element.localName} is requesting the url ${url}`);\n    }\n\n    return super.fetch(url, options);\n  }\n}\n```\n\n### 虚拟控制台\n\n像网页浏览器一样，jsdom 也具有“控制台”的概念。通过在文档内执行的脚本以及来自 jsdom 本身实现的信息和记录会从页面直接发送过来。我们将用户可控制的控制台称为“虚拟控制台”，以便将其与 Node.js `console` API 和页面内部的 `window.console` API 区分开来。\n\n默认情况下，`JSDOM` 构造函数将返回一个具有虚拟控制台的实例，该虚拟控制台将其所有输出转发到 Node.js 控制台。为了创建自己的虚拟控制台并将其传递给 jsdom，可以通过执行下面代码来覆盖此默认值\n\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n\n这样的代码将创建一个没有任何行为的虚拟控制台。您可以为所有可能的控制台方法添加事件侦听器来为其提供行为：\n\n```js\nvirtualConsole.on(\"error\", () =\u003E { ... });\nvirtualConsole.on(\"warn\", () =\u003E { ... });\nvirtualConsole.on(\"info\", () =\u003E { ... });\nvirtualConsole.on(\"dir\", () =\u003E { ... });\n\u002F\u002F ... etc. See https:\u002F\u002Fconsole.spec.whatwg.org\u002F#logging\n```\n\n（请注意，最好在调用 `new JSDOM()` 之前设置这些事件侦听器，因为在解析期间可能会发生错误或控制台调用脚本错误。）\n\n如果你只是想将虚拟控制台输出重定向到另一个控制台，比如默认的 Node.js，你可以这样做\n\n```js\nvirtualConsole.sendTo(console);\n```\n\n还有一个特殊的事件，`\"jsdomError\"`，它的触发将通过错误对象来记录 jsdom 本身的错误。这与错误消息在 Web 浏览器控制台中的显示方式类似，即使它们不是由 console.error 输出的。到目前为止，错误会按照下面的方式输出：\n\n- 加载或解析子资源时出错（脚本，样式表，frames 和 iframe）\n- 不是由 window `onerror` 事件处理程序处理的脚本执行错误，它将会返回 `true` 或调用 `event.preventDefault()`\n- 由于调用 jsdom 没有实现的方法而导致的错误，例如 `window.alert`，兼容性的 Web 浏览器都实现了这些方法\n\n如果您使用 `sendTo(c)` 将错误发送给 `c`，则默认情况下，它将使用来自`\"jsdomError\"`事件的信息调用 `c.error(errorStack[, errorDetail])`。如果您希望保持事件与方法调用的严格的一对一映射，并且可能自己处理`\"jsdomError\"`，那么您可以执行\n\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n\n### Cookie 容器\n\n像网页浏览器一样，jsdom 也具有 cookie 容器的概念，存储 HTTP cookie。在文档的同一个域上一个 URL，并且没有标记为 HTTP-only 的 cookies，可以通过`document.cookie` API 来访问。此外，cookie 容器中的所有 cookie 都会影响子资源的加载。\n\n默认情况下，`JSDOM` 构造函数将返回一个带有空 cookie 的实例。要创建自己的 cookie 容器并将其传递给 jsdom，可以通过以下代码来覆盖默认值\n\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n\n如果您想要在多个 jsdom 中共享同一个 cookie 容器，或者提前使用特定的值来填充 cookie 容器，这将非常有用。\n\nCookie jar 由 [tough-cookie](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Ftough-cookie) 包提供。`jsdom.CookieJar`构造函数是 tough-cookie cookie 容器的子类，并且默认设置了 `looseMode：true` 选项，因为它[更符合浏览器的行为方式](https:\u002F\u002Fgithub.com\u002Fwhatwg\u002Fhtml\u002Fissues\u002F804)。如果您想自己使用 tough-cookie 的方法和类，则可以使用 `jsdom.toughCookie` 模块导出来访问使用 jsdom 打包的 tough-cookie 模块实例。\n\n### 在解析之前进行干预\n\njsdom 允许您在很早的时候介入创建 jsdom：创建 Window 和 Document 对象之后，但在解析任何 HTML 并使用节点填充文档之前：\n\n```js\nconst dom = new JSDOM(`\u003Cp\u003EHello\u003C\u002Fp\u003E`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () =\u003E { \u002F* ... *\u002F };\n  }\n});\n```\n\n如果您想以某种方式修改环境，例如为 jsdom 不支持的 Web 平台 API 添加 shim，这将特别有用。\n\n## `JSDOM` object API\n\n一旦你构建了一个 `JSDOM` 对象，它将具有以下有用的功能：\n\n### Properties\n\n`window` 属性: `window` 对象的 key 从 `Window` 对象检索而来。\n\n`virtualConsole` 和 `cookieJar`：可以传入或者使用默认值。\n\n### 通过 `serialize()` 序列化 document\n\n`serialize()` 方法将返回文档的 [HTML 序列化](https:\u002F\u002Fhtml.spec.whatwg.org\u002F#html-fragment-serialisation-algorithm)，包括 doctype：\n\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003Ehello`);\n\ndom.serialize() === \"\u003C!DOCTYPE html\u003E\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n\n\u002F\u002F 对比:\ndom.window.document.documentElement.outerHTML === \"\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n```\n\n### 通过 `nodeLocation(node)` 获取节点的源位置信息\n\n`nodeLocation()`方法将查找 DOM 节点在源文档中的位置，并返回节点的 [parse5 位置信息](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fparse5#options-locationinfo)：\n\n```js\nconst dom = new JSDOM(\n  `\u003Cp\u003EHello\n    \u003Cimg src=\"foo.jpg\"\u003E\n  \u003C\u002Fp\u003E`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; \u002F\u002F implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   \u002F\u002F null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      \u002F\u002F { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); \u002F\u002F { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    \u002F\u002F { startOffset: 13, endOffset: 32 }\n```\n\n请注意，只有设置了 `includeNodeLocations` 选项才能使用此功能；由于性能原因这个选项默认为关闭。\n\n### 使用 `getInternalVMContext()` 与 Node.js `vm` 模块交互\n\nNode.js 的内置 [`vm`](https:\u002F\u002Fnodejs.org\u002Fapi\u002Fvm.html) 模块是 jsdom 脚本运行魔法的基础。一些高级用例，例如预编译脚本然后多次运行，可以通过直接使用 `vm` 模块和 jsdom 创建的 `Window` 实现。\n\n可以使用 `getInternalVMContext()` 方法获取与 `vm` API 一起使用的[上下文化的全局对象](https:\u002F\u002Fnodejs.org\u002Fapi\u002Fvm.html#vm_what_does_it_mean_to_contextify_an_object)：\n\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst script = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\nconst vmContext = dom.getInternalVMContext();\n\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\nscript.runInContext(vmContext);\n\nconsole.assert(dom.window.ran === 3);\n```\n\n这是高级功能，除非您有特殊的需求，否则我们建议坚持使用普通的 DOM API（如 `window.eval()` 或 `document.createElement(\"script\")`）。\n\n请注意，如果在没有设置 `runScripts` 的情况下创建了 `JSDOM` 实例，或者如果您 [在 Web 浏览器中使用 jsdom](#在-web-浏览器中运行-jsdom)，此方法将抛出异常。\n\n### 通过`reconfigure(settings)`重新配置 jsdom\n\n`window.top`属性在规范中被标记为[Unforgeable][中文：伪造的]，这意味着它是一个不可配置的私有属性，因此在 jsdom 内运行的普通代码是不能覆盖或遮挡它的，即使使用`Object.defineProperty`。\n\n同样，目前在 jsdom 中是不能够处理`navigation`相关信息的（比如设置`window.location.href =\"https:\u002F\u002Fexample.com\u002F\"`）;这样做会导致虚拟控制台发出`\"jsdomError\"`，说明此功能未实现，并且没有任何变化,也将不会有新的`Window`或`Document`对象，并且现有`window.location`对象仍保持当前所有相同的属性值。\n\n但是，如果您从 jsdom 窗口之外进行演示，例如在一些创建 jsdoms 的测试框架中，可以使用特殊的`reconfigure()`方法覆盖其中的一个或两个：\n\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({\n  windowTop: myFakeTopForTesting,\n  url: \"https:\u002F\u002Fexample.com\u002F\",\n});\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https:\u002F\u002Fexample.com\u002F\";\n```\n\n请注意，更改 jsdom 的 URL 将影响所有返回当前 document URL 的 API，例如`window.location`，` document.URL``和document.documentURI `，以及文档中相对 URL 的解析以及同源检查和提取子资源时使用的引用。但是，它不会执行导航到该 URL 的内容;DOM 的内容将保持不变，并且不会创建`Window`，`Document`等新的实例。\n\n## 便捷的 API\n\n### `fromURL()`\n\n除了 `JSDOM` 构造函数本身之外，jsdom 还提供了一个返回 Promise 的工厂方法，用于通过 URL 构建一个 jsdom 实例：\n\n```js\nJSDOM.fromURL(\"https:\u002F\u002Fexample.com\u002F\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\n如果 URL 有效且请求成功，则 `onFullfilled` 回调执行并返回 `JSDOM` 实例。任何 URL 重定向都将遵循其最终目的地。\n\n`fromURL()` 提供的选项与提供给 `JSDOM` 构造函数的选项类似，但具有以下额外的限制和后果：\n\n- `url` 和 `contentType` 参数不能被提供。\n- `referrer` 选项用作初始请求的 HTTP `Referer` 请求头。\n- `resources` 选项也会影响初始请求；这很有用，例如，如果您想配置代理（见上文）。\n- 生成的 jsdom 的 URL、内容类型和来源是由响应来决定。\n- 任何通过 HTTP `Set-Cookie` 响应头设置的 cookie 都存储在 jsdom 的 cookie 容器中。同样，已提供的 cookie 容器中的任何 cookie 都会作为 HTTP `Cookie` 请求头发送。\n\n### `fromFile()`\n\n与 `fromURL()` 类似，jsdom 还提供了一个 `fromFile()` 工厂方法，用于从文件名构建 jsdom：\n\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\n如果可以打开给定的文件，则 `onFullfilled` 回调执行并返回 `JSDOM` 实例。和 Node.js API 一样，文件名是相对于当前工作目录的。\n\n`fromFile()` 提供的选项与提供给 `JSDOM` 构造函数的选项相似，但具有以下额外的默认值：\n\n- `url` 选项将默认为给定文件名相对应的文件 URL，而不是 `\"about：blank\"`。\n- 假如给定的文件名是以 `.xht`、`.xhtml` 或者 `.xml` 为后缀的话，`contentType` 选项默认为 `\"application\u002Fxhtml+xml\"`；反之为 `\"text\u002Fhtml\"`。\n\n### `fragment()`\n\n对于最简单的情况，你可能不需要一个完整的 `JSDOM` 实例及其所有相关的功能。您甚至可能不需要 `Window` 或 `Document`！相反，你只需要解析一些 HTML 片段，并获得一个你可以操作的 DOM 对象。为此，我们提供了 `fragment()`，它可以从给定的字符串中创建一个` DocumentFragment`：\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EHi!\u003C\u002Fstrong\u003E`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent === \"Hi!\";\n\u002F\u002F etc.\n```\n\n`frag` 是 [`DocumentFragment`](https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FAPI\u002FDocumentFragment) 的实例对象，其内容是通过提供的字符串解析创建的。解析是通过使用 `\u003Ctemplate\u003E` 元素完成的，因此您可以在其中包含任何元素（包括具有奇怪解析规则的元素，如 `\u003Ctd\u003E`）。还需要注意的是，生成的 `DocumentFragment` 不会有[关联的浏览上下文](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002F#concept-document-bc)：即元素的 `ownerDocument` 将有一个空的 `defaultView` 属性，资源不会加载，等等。\n\n`fragment()` 工厂函数的所有调用结果的 `DocumentFragments` 实例都会共享相同的 `Document`。这允许多次调用 `fragment()` 而没有额外的开销。但这也意味着对 `fragment()` 的调用不能用任何选项自定义。\n\n请注意，对 `DocumentFragments` 的序列化并不像使用 `JSDOM` 对象那样容易。如果你需要序列化你的 DOM ，你应该直接使用 `JSDOM` 构造函数。但对于包含单个元素的片段的特殊情况，通过常规方法就很容易做到。\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E`);\nconsole.log(frag.firstChild.outerHTML); \u002F\u002F logs \"\u003Cp\u003EHello\u003C\u002Fp\u003E\"\n```\n\n## 其他值得注意的功能\n\n### 支持 Canvas\n\njsdom 支持使用 [`canvas`](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fcanvas) 包来扩展任何使用 canvas API 的 `\u003Ccanvas\u003E` 元素。为了做到这一点，您需要将 `canvas` 作为依赖项加入到您的项目中，和 `jsdom` 包并列。如果 jsdom 可以找到 `canvas` 包，它将使用它，但是如果它不存在，那么 `\u003Ccanvas\u003E` 元素的行为就像 `\u003Cdiv\u003E` 一样。从 jsdom v13 开始，需要 `canvas` 的 2.x 版本；不再支持 1.x 版。\n\n### 编码嗅探\n\n除了提供一个字符串外，`JSDOM` 构造函数还支持 Node.js [`Buffer`](https:\u002F\u002Fnodejs.org\u002Fdocs\u002Flatest\u002Fapi\u002Fbuffer.html)或标准 JavaScript 二进制数据类型（如 `ArrayBuffer`，`Uint8Array`，`DataView` 等）的形式提供二进制数据。当完成后，jsdom 将就像浏览器一样从提供的字节进行[嗅探编码](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fsyntax.html#encoding-sniffing-algorithm)，扫描 `\u003Cmeta charset\u003E` 标签。\n\n如果提供的 `contentType` 选项包含 `charset` 参数，则该编码将覆盖嗅探的编码 - 除非存在 UTF-8 或 UTF-16 BOM，在这种情况下嗅探的编码优先。（同样就像浏览器。）\n\n这种编码嗅探也适用于 `JSDOM.fromFile()` 和 `JSDOM.fromURL()`。在后一种情况下，就像在浏览器中一样，任何与响应一起发送的 `Content-Type` 头信息优先级更高，与构造函数的 `contentType` 选项的方式相同。\n\n请注意，在许多情况下，提供字节这种方式可能比提供字符串更好。例如，如果您试图使用 Node.js 的 `buffer.toString('utf-8')` API，则 Node.js 将不会去除任何前导 BOM。如果您将此字符串提供给 jsdom，它会逐字解释，从而使 BOM 保持不变。但 jsdom 的二进制数据解码代码将剥离前导的 BOM，就像浏览器一样；在这种情况下，直接提供 `buffer` 将会得到想要的结果。\n\n### 关闭 jsdom\n\njsdom 中定义的定时器（通过 `window.setTimeout()` 或 `window.setInterval()` 设置）将在 window 上下文中执行代码。由于进程在不活跃的情况下无法执行未来的定时器代码，所以卓越的 jsdom 定时器将保持您的 Node.js 进程处于活动状态。同样，对象不活跃的情况下也没有办法在对象的上下文中执行代码，卓越的 jsdom 定时器将阻止垃圾回收调度它们的 window。\n\n如果你想确保关闭 jsdom 窗口，使用 `window.close()`，它将终止所有正在运行的定时器（并且还会删除 `window` 和 `document` 上的任何事件监听器）。\n\n### 在 Web 浏览器中运行 jsdom\n\n使用 [browserify](http:\u002F\u002Fbrowserify.org\u002F) 模块，jsdom 某些方面也支持在 Web 浏览器中运行。也就是说，在 Web 浏览器中，您可以使用被 `browserify` 模块编译过的 jsdom 去创建完全独立的普通 JavaScript 对象集，其外观和行为与浏览器的现有 DOM 对象非常相似，但完全独立于它们，也就是“虚拟 DOM”！\n\njsdom 的主要目标对象仍然是 Node.js，因此我们使用仅存在于最新 Node.js 版本中的语言特性功能。因此，在旧版浏览器可能无法正常工作。（即使编译也不会有多大帮助：我们在整个 jsdom 代码库中广泛使用 `Proxy`。）\n\n值得注意的是，jsdom 在 Web Worker 中能很好的运行。项目的开发者 [@lawnsea](https:\u002F\u002Fgithub.com\u002Flawnsea\u002F) 使这一功能点成为可能，他发表了一篇关于他的[项目的论文](https:\u002F\u002Fpdfs.semanticscholar.org\u002F47f0\u002F6bb6607a975500a30e9e52d7c9fbc0034e27.pdf)，该论文就使用了这种能力。\n\n在 Web 浏览器中运行 jsdom 时，并非所有的工作都完美。有些情况下，这是由于基础的条件限制（比如没有文件系统访问），但有些情况下也是因为我们没有花足够的时间去进行适当的小调整。欢迎大家来提 bug。\n\n### 使用 Chrome 开发者工具调试 DOM\n\n可以使用 Chrome 开发者工具来调试 Node.js 程序。请参阅[官方文档](https:\u002F\u002Fnodejs.org\u002Fen\u002Fdocs\u002Finspector\u002F)了解如何使用。\n\n默认情况下，jsdom 元素在控制台中被格式化为普通的旧 JS 对象。为了便于调试，可以使用[jsdom-devtools-formatter](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom-devtools-formatter)，它可以让你像真正的 DOM 元素一样调试它们。\n\n## 注意事项\n\n### 异步脚本加载\n\n使用 jsdom 时，开发者在加载异步脚本时经常遇到麻烦。许多页面异步加载脚本，但无法分辨脚本什么时候完成，因此无法知道何时是运行代码并检查生成的 DOM 结构的好时机。这是一个基本的限制；我们无法预测网页上的哪些脚本会做什么，因此无法告诉您脚本何时加载完毕。\n\n这个问题可以通过几种方法来解决。如果您能控制页面逻辑，最好的方法是使用脚本加载器提供的机制来检测何时加载完成。例如，如果您使用像 RequireJS 这样的模块加载器，代码可能如下所示：\n\n```js\n\u002F\u002F On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () =\u003E {\n  console.log(\"ready to roll!\");\n};\n```\n\n```js\n\u003C!-- Inside the HTML you supply to jsdom --\u003E\n\u003Cscript\u003E\nrequirejs([\"entry-module\"], () =\u003E {\n  window.onModulesLoaded();\n});\n\u003C\u002Fscript\u003E\n```\n\n如果您不能控制该页面，则可以尝试其他解决方法，例如轮询检查特定元素是否存在。\n\n有关更多详细信息，请查看[#640](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues\u002F640)中的讨论，尤其是 [@matthewkastor](https:\u002F\u002Fgithub.com\u002Fmatthewkastor) 的[深刻见解](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues\u002F640#issuecomment-22216965)。\n\n### 未实现的 Web 平台部分\n\n目前 jsdom 中有很多缺失的 API，尽管我们也想要在 jsdom 中添加新的功能并保持最新的 Web 规范。请随时为缺失的任何内容提交 issue，但我们是一个很小并且忙碌的团队，因此大家一起来提交 pull request 可能会更好。\n\n除了我们尚未拥有的功能之外，还有两个主要功能目前超出了 jsdom 的范围。这些是：\n\n- **导航**：在点击链接或赋值 `location.href` 或类似操作时可以更改全局对象和所有其他的对象。\n- **布局**：计算 CSS 元素的视觉布局的能力，这会影响诸如 `getBoundingClientRects()` 或者诸如 `offsetTop` 之类的属性。\n\n目前，jsdom 对某些功能的某些方面具有虚拟行为，例如操作导航时向虚拟控制台发送“未实现的”`\"jsdomError\"`，或者为许多与布局相关的属性返回 0。您通常可以在代码中解决这些限制，例如通过在爬网过程中为每个页面创建新的 `JSDOM` 实例，或使用 `Object.defineProperty()` 更改各种与布局相关的 getter 和方法的返回值\n\n请注意，相同领域中的其他工具（如 PhantomJS）确实支持这些功能。在 wiki 上，我们有关于 [jsdom 与 PhantomJS 比较](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fwiki\u002Fjsdom-vs.-PhantomJS)的更完整的介绍。\n\n## 支持jsdom\n\njsdom 是一个社区驱动的项目，由[志愿者](https:\u002F\u002Fgithub.com\u002Forgs\u002Fjsdom\u002Fpeople)团队维护。您可以通过以下方式支持 jsdom：\n\n- 在 Tidelift 订阅中[获得对 jsdom 的专业支持](https:\u002F\u002Ftidelift.com\u002Fsubscription\u002Fpkg\u002Fnpm-jsdom?utm_source=npm-jsdom&utm_medium=referral&utm_campaign=readme)。Tidelift 帮助我们实现开源的可持续发展，同时为团队提供维护、许可和安全方面的保证。\n- 直接对项目[做贡献](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fblob\u002Fmaster\u002FContributing.md)。\n\n## 获取帮助\n\n如果您需要 jsdom 的帮助，请随时使用以下任何方式：\n\n- [邮件组](https:\u002F\u002Fgroups.google.com\u002Fgroup\u002Fjsdom)（最好以 “how do I” 的形式提问）\n- [提 issue](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fissues)（最好用来提 bug）\n- Matrix 房间：[#jsdom:matrix.org](https:\u002F\u002Fmatrix.to\u002F#\u002F#jsdom:matrix.org)\n",
    "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118::files\u002Fen-us\u002Fgithub\u002Fjsdom.md": "\u003Ch1 align=\"center\"\u003E\n    \u003Cimg width=\"100\" height=\"100\" src=\"logo.svg\" alt=\"\"\u003E\u003Cbr\u003E\n    jsdom\n\u003C\u002Fh1\u003E\n\njsdom is a pure-JavaScript implementation of many web standards, notably the WHATWG [DOM](https:\u002F\u002Fdom.spec.whatwg.org\u002F) and [HTML](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002F) Standards, for use with Node.js. In general, the goal of the project is to emulate enough of a subset of a web browser to be useful for testing and scraping real-world web applications.\n\nThe latest versions of jsdom require Node.js v6 or newer. (Versions of jsdom below v10 still work with Node.js v4, but are unsupported.)\n\nAs of v10, jsdom has a new API (documented below). The old API is still supported for now; [see its documentation](.\u002Flib\u002Fold-api.md) for details.\n\n## Basic usage\n\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n\nTo use jsdom, you will primarily use the `JSDOM` constructor, which is a named export of the jsdom main module. Pass the constructor a string. You will get back a `JSDOM` object, which has a number of useful properties, notably `window`:\n\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003E\u003Cp\u003EHello world\u003C\u002Fp\u003E`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); \u002F\u002F \"Hello world\"\n```\n\n(Note that jsdom will parse the HTML you pass it just like a browser does, including implied `\u003Chtml\u003E`, `\u003Chead\u003E`, and `\u003Cbody\u003E` tags.)\n\nThe resulting object is an instance of the `JSDOM` class, which contains a number of useful properties and methods besides `window`. In general it can be used to act on the jsdom from the \"outside,\" doing things that are not possible with the normal DOM APIs. For simple cases, where you don't need any of this functionality, we recommend a coding pattern like\n\n```js\nconst { window } = new JSDOM(`...`);\n\u002F\u002F or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n\nFull documentation on everything you can do with the `JSDOM` class is below, in the section \"`JSDOM` Object API\".\n\n## Customizing jsdom\n\nThe `JSDOM` constructor accepts a second parameter which can be used to customize your jsdom in the following ways.\n\n### Simple options\n\n```js\nconst dom = new JSDOM(``, {\n  url: \"https:\u002F\u002Fexample.org\u002F\",\n  referrer: \"https:\u002F\u002Fexample.com\u002F\",\n  contentType: \"text\u002Fhtml\",\n  userAgent: \"Mellblomenator\u002F9000\",\n  includeNodeLocations: true\n});\n```\n\n- `url` sets the value returned by `window.location`, `document.URL`, and `document.documentURI`, and affects things like resolution of relative URLs within the document and the same-origin restrictions and referrer used while fetching subresources. It defaults to `\"about:blank\"`.\n- `referrer` just affects the value read from `document.referrer`. It defaults to no referrer (which reflects as the empty string).\n- `contentType` affects the value read from `document.contentType`, and how the document is parsed: as HTML or as XML. Values that are not `\"text\u002Fhtml\"` or an [XML mime type](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Finfrastructure.html#xml-mime-type) will throw. It defaults to `\"text\u002Fhtml\"`.\n- `userAgent` affects the value read from `navigator.userAgent`, as well as the `User-Agent` header sent while fetching subresources. It defaults to \u003Ccode\u003E\\`Mozilla\u002F5.0 (${process.platform}) AppleWebKit\u002F537.36 (KHTML, like Gecko) jsdom\u002F${jsdomVersion}\\`\u003C\u002Fcode\u003E.\n- `includeNodeLocations` preserves the location info produced by the HTML parser, allowing you to retrieve it with the `nodeLocation()` method (described below). It also ensures that line numbers reported in exception stack traces for code running inside `\u003Cscript\u003E` elements are correct. It defaults to `false` to give the best performance, and cannot be used with an XML content type since our XML parser does not support location info.\n\nNote that both `url` and `referrer` are canonicalized before they're used, so e.g. if you pass in `\"https:example.com\"`, jsdom will interpret that as if you had given `\"https:\u002F\u002Fexample.com\u002F\"`. If you pass an unparseable URL, the call will throw. (URLs are parsed and serialized according to the [URL Standard](http:\u002F\u002Furl.spec.whatwg.org\u002F).)\n\n### Executing scripts\n\njsdom's most powerful ability is that it can execute scripts inside the jsdom. These scripts can modify the content of the page and access all the web platform APIs jsdom implements.\n\nHowever, this is also highly dangerous when dealing with untrusted content. The jsdom sandbox is not foolproof, and code running inside the DOM's `\u003Cscript\u003E`s can, if it tries hard enough, get access to the Node.js environment, and thus to your machine. As such, the ability to execute scripts embedded in the HTML is disabled by default:\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`);\n\n\u002F\u002F The script will not be executed, by default:\ndom.window.document.body.children.length === 1;\n```\n\nTo enable executing scripts inside the page, you can use the `runScripts: \"dangerously\"` option:\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`, { runScripts: \"dangerously\" });\n\n\u002F\u002F The script will be executed and modify the DOM:\ndom.window.document.body.children.length === 2;\n```\n\nAgain we emphasize to only use this when feeding jsdom code you know is safe. If you use it on arbitrary user-supplied code, or code from the Internet, you are effectively running untrusted Node.js code, and your machine could be compromised.\n\nIf you want to execute _external_ scripts, included via `\u003Cscript src=\"\"\u003E`, you'll also need to ensure that they load them. To do this, add the option `resources: \"usable\"` [as described below](#loading-subresources).\n\nNote that event handler attributes, like `\u003Cdiv onclick=\"\"\u003E`, will also not function unless `runScripts` is set to `\"dangerously\"`. (However, event handler _properties_, like `div.onclick = ...`, will function regardless of `runScripts`.)\n\nIf you are simply trying to execute script \"from the outside\", instead of letting `\u003Cscript\u003E` elements (and inline event handlers) run \"from the inside\", you can use the `runScripts: \"outside-only\"` option, which enables `window.eval`:\n\n```js\nconst window = (new JSDOM(``, { runScripts: \"outside-only\" })).window;\n\nwindow.eval(`document.body.innerHTML = \"\u003Cp\u003EHello, world!\u003C\u002Fp\u003E\";`);\nwindow.document.body.children.length === 1;\n```\n\nThis is turned off by default for performance reasons, but is safe to enable.\n\nNote that we strongly advise against trying to \"execute scripts\" by mashing together the jsdom and Node global environments (e.g. by doing `global.window = dom.window`), and then executing scripts or test code inside the Node global environment. Instead, you should treat jsdom like you would a browser, and run all scripts and tests that need access to a DOM inside the jsdom environment, using `window.eval` or `runScripts: \"dangerously\"`. This might require, for example, creating a browserify bundle to execute as a `\u003Cscript\u003E` element—just like you would in a browser.\n\nFinally, for advanced use cases you can use the `dom.runVMScript(script)` method, documented below.\n\n### Pretending to be a visual browser\n\njsdom does not have the capability to render visual content, and will act like a headless browser by default. It provides hints to web pages through APIs such as `document.hidden` that their content is not visible.\n\nWhen the `pretendToBeVisual` option is set to `true`, jsdom will pretend that it is rendering and displaying content. It does this by:\n\n* Changing `document.hidden` to return `false` instead of `true`\n* Changing `document.visibilityState` to return `\"visible\"` instead of `\"prerender\"`\n* Enabling `window.requestAnimationFrame()` and `window.cancelAnimationFrame()` methods, which otherwise do not exist\n\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp =\u003E {\n  console.log(timestamp \u003E 0);\n});\n```\n\nNote that jsdom still [does not do any layout or rendering](#unimplemented-parts-of-the-web-platform), so this is really just about _pretending_ to be visual, not about implementing the parts of the platform a real, visual web browser would implement.\n\n### Loading subresources\n\nBy default, jsdom will not load any subresources such as scripts, stylesheets, images, or iframes. If you'd like jsdom to load such resources, you can pass the `resources: \"usable\"` option, which will load all usable resources. Those are:\n\n* Frames and iframes, via `\u003Cframe\u003E` and `\u003Ciframe\u003E`\n* Stylesheets, via `\u003Clink rel=\"stylesheet\"\u003E`\n* Scripts, via `\u003Cscript\u003E`, but only if `runScripts: \"dangerously\"` is also set\n* Images, via `\u003Cimg\u003E`, but only if the `canvas` (or `canvas-prebuilt`) npm package is also installed (see \"Canvas Support\" below)\n\nIn the future we plan to offer more customization of resource loading via this option, but for now the default and the `\"usable\"` option are the two modes offered.\n\n### Virtual consoles\n\nLike web browsers, jsdom has the concept of a \"console\". This records both information directly sent from the page, via scripts executing inside the document, as well as information from the jsdom implementation itself. We call the user-controllable console a \"virtual console\", to distinguish it from the Node.js `console` API and from the inside-the-page `window.console` API.\n\nBy default, the `JSDOM` constructor will return an instance with a virtual console that forwards all its output to the Node.js console. To create your own virtual console and pass it to jsdom, you can override this default by doing\n\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n\nCode like this will create a virtual console with no behavior. You can give it behavior by adding event listeners for all the possible console methods:\n\n```js\nvirtualConsole.on(\"error\", () =\u003E { ... });\nvirtualConsole.on(\"warn\", () =\u003E { ... });\nvirtualConsole.on(\"info\", () =\u003E { ... });\nvirtualConsole.on(\"dir\", () =\u003E { ... });\n\u002F\u002F ... etc. See https:\u002F\u002Fconsole.spec.whatwg.org\u002F#logging\n```\n\n(Note that it is probably best to set up these event listeners *before* calling `new JSDOM()`, since errors or console-invoking script might occur during parsing.)\n\nIf you simply want to redirect the virtual console output to another console, like the default Node.js one, you can do\n\n```js\nvirtualConsole.sendTo(console);\n```\n\nThere is also a special event, `\"jsdomError\"`, which will fire with error objects to report errors from jsdom itself. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by `console.error`. So far, the following errors are output this way:\n\n- Errors loading or parsing subresources (scripts, stylesheets, frames, and iframes)\n- Script execution errors that are not handled by a window `onerror` event handler that returns `true` or calls `event.preventDefault()`\n- Not-implemented errors resulting from calls to methods, like `window.alert`, which jsdom does not implement, but installs anyway for web compatibility\n\nIf you're using `sendTo(c)` to send errors to `c`, by default it will call `console.error` with information from `\"jsdomError\"` events. If you'd prefer to maintain a strict one-to-one mapping of events to method calls, and perhaps handle `\"jsdomError\"`s yourself, then you can do\n\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n\n### Cookie jars\n\nLike web browsers, jsdom has the concept of a cookie jar, storing HTTP cookies. Cookies that have a URL on the same domain as the document, and are not marked HTTP-only, are accessible via the `document.cookie` API. Additionally, all cookies in the cookie jar will impact the fetching of subresources.\n\nBy default, the `JSDOM` constructor will return an instance with an empty cookie jar. To create your own cookie jar and pass it to jsdom, you can override this default by doing\n\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n\nThis is mostly useful if you want to share the same cookie jar among multiple jsdoms, or prime the cookie jar with certain values ahead of time.\n\nCookie jars are provided by the [tough-cookie](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Ftough-cookie) package. The `jsdom.CookieJar` constructor is a subclass of the tough-cookie cookie jar which by default sets the `looseMode: true` option, since that [matches better how browsers behave](https:\u002F\u002Fgithub.com\u002Fwhatwg\u002Fhtml\u002Fissues\u002F804). If you want to use tough-cookie's utilities and classes yourself, you can use the `jsdom.toughCookie` module export to get access to the tough-cookie module instance packaged with jsdom.\n\n### Intervening before parsing\n\njsdom allows you to intervene in the creation of a jsdom very early: after the `Window` and `Document` objects are created, but before any HTML is parsed to populate the document with nodes:\n\n```js\nconst dom = new JSDOM(`\u003Cp\u003EHello\u003C\u002Fp\u003E`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () =\u003E { \u002F* ... *\u002F };\n  }\n});\n```\n\nThis is especially useful if you are wanting to modify the environment in some way, for example adding shims for web platform APIs jsdom does not support.\n\n## `JSDOM` object API\n\nOnce you have constructed a `JSDOM` object, it will have the following useful capabilities:\n\n### Properties\n\nThe property `window` retrieves the `Window` object that was created for you.\n\nThe properties `virtualConsole` and `cookieJar` reflect the options you pass in, or the defaults created for you if nothing was passed in for those options.\n\n### Serializing the document with `serialize()`\n\nThe `serialize()` method will return the [HTML serialization](https:\u002F\u002Fhtml.spec.whatwg.org\u002F#html-fragment-serialisation-algorithm) of the document, including the doctype:\n\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003Ehello`);\n\ndom.serialize() === \"\u003C!DOCTYPE html\u003E\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n\n\u002F\u002F Contrast with:\ndom.window.document.documentElement.outerHTML === \"\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n```\n\n### Getting the source location of a node with `nodeLocation(node)`\n\nThe `nodeLocation()` method will find where a DOM node is within the source document, returning the [parse5 location info](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fparse5#options-locationinfo) for the node:\n\n```js\nconst dom = new JSDOM(\n  `\u003Cp\u003EHello\n    \u003Cimg src=\"foo.jpg\"\u003E\n  \u003C\u002Fp\u003E`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; \u002F\u002F implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   \u002F\u002F null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      \u002F\u002F { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); \u002F\u002F { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    \u002F\u002F { startOffset: 13, endOffset: 32 }\n```\n\nNote that this feature only works if you have set the `includeNodeLocations` option; node locations are off by default for performance reasons.\n\n### Running vm-created scripts with `runVMScript(script)`\n\nThe built-in `vm` module of Node.js allows you to create `Script` instances, which can be compiled ahead of time and then run multiple times on a given \"VM context\". Behind the scenes, a jsdom `Window` is indeed a VM context. To get access to this ability, use the `runVMScript()` method:\n\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst s = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\ndom.runVMScript(s);\ndom.runVMScript(s);\ndom.runVMScript(s);\n\ndom.window.ran === 3;\n```\n\nThis is somewhat-advanced functionality, and we advise sticking to normal DOM APIs (such as `window.eval()` or `document.createElement(\"script\")`) unless you have very specific needs.\n\n### Reconfiguring the jsdom with `reconfigure(settings)`\n\nThe `top` property on `window` is marked `[Unforgeable]` in the spec, meaning it is a non-configurable own property and thus cannot be overridden or shadowed by normal code running inside the jsdom, even using `Object.defineProperty`.\n\nSimilarly, at present jsdom does not handle navigation (such as setting `window.location.href = \"https:\u002F\u002Fexample.com\u002F\"`); doing so will cause the virtual console to emit a `\"jsdomError\"` explaining that this feature is not implemented, and nothing will change: there will be no new `Window` or `Document` object, and the existing `window`'s `location` object will still have all the same property values.\n\nHowever, if you're acting from outside the window, e.g. in some test framework that creates jsdoms, you can override one or both of these using the special `reconfigure()` method:\n\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({ windowTop: myFakeTopForTesting, url: \"https:\u002F\u002Fexample.com\u002F\" });\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https:\u002F\u002Fexample.com\u002F\";\n```\n\nNote that changing the jsdom's URL will impact all APIs that return the current document URL, such as `window.location`, `document.URL`, and `document.documentURI`, as well as resolution of relative URLs within the document, and the same-origin checks and referrer used while fetching subresources. It will not, however, perform a navigation to the contents of that URL; the contents of the DOM will remain unchanged, and no new instances of `Window`, `Document`, etc. will be created.\n\n## Convenience APIs\n\n### `fromURL()`\n\nIn addition to the `JSDOM` constructor itself, jsdom provides a promise-returning factory method for constructing a jsdom from a URL:\n\n```js\nJSDOM.fromURL(\"https:\u002F\u002Fexample.com\u002F\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the URL is valid and the request is successful. Any redirects will be followed to their ultimate destination.\n\nThe options provided to `fromURL()` are similar to those provided to the `JSDOM` constructor, with the following additional restrictions and consequences:\n\n- The `url` and `contentType` options cannot be provided.\n- The `referrer` option is used as the HTTP `Referer` request header of the initial request.\n- The `userAgent` option is used as the HTTP `User-Agent` request header of any requests.\n- The resulting jsdom's URL, content type, and referrer are determined from the response.\n- Any cookies set via HTTP `Set-Cookie` response headers are stored in the jsdom's cookie jar. Similarly, any cookies already in a supplied cookie jar are sent as HTTP `Cookie` request headers.\n\nThe initial request is not infinitely customizable to the same extent as is possible in a package like [request](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Frequest); `fromURL()` is meant to be a convenience API for the majority of cases. If you need greater control over the initial request, you should perform it yourself, and then use the `JSDOM` constructor manually.\n\n### `fromFile()`\n\nSimilar to `fromURL()`, jsdom also provides a `fromFile()` factory method for constructing a jsdom from a filename:\n\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\nThe returned promise will fulfill with a `JSDOM` instance if the given file can be opened. As usual in Node.js APIs, the filename is given relative to the current working directory.\n\nThe options provided to `fromFile()` are similar to those provided to the `JSDOM` constructor, with the following additional defaults:\n\n- The `url` option will default to a file URL corresponding to the given filename, instead of to `\"about:blank\"`.\n- The `contentType` option will default to `\"application\u002Fxhtml+xml\"` if the given filename ends in `.xhtml` or `.xml`; otherwise it will continue to default to `\"text\u002Fhtml\"`.\n\n### `fragment()`\n\nFor the very simplest of cases, you might not need a whole `JSDOM` instance with all its associated power. You might not even need a `Window` or `Document`! Instead, you just need to parse some HTML, and get a DOM object you can manipulate. For that, we have `fragment()`, which creates a `DocumentFragment` from a given string:\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EHi!\u003C\u002Fstrong\u003E`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent = \"Why hello there!\";\n\u002F\u002F etc.\n```\n\nHere `frag` is a [`DocumentFragment`](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FDocumentFragment) instance, whose contents are created by parsing the provided string. The parsing is done using a `\u003Ctemplate\u003E` element, so you can include any element there (including ones with weird parsing rules like `\u003Ctd\u003E`).\n\nAll invocations of the `fragment()` factory result in `DocumentFragment`s that share the same owner `Document` and `Window`. This allows many calls to `fragment()` with no extra overhead. But it also means that calls to `fragment()` cannot be customized with any options.\n\nNote that serialization is not as easy with `DocumentFragment`s as it is with full `JSDOM` objects. If you need to serialize your DOM, you should probably use the `JSDOM` constructor more directly. But for the special case of a fragment containing a single element, it's pretty easy to do through normal means:\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E`);\nconsole.log(frag.firstChild.outerHTML); \u002F\u002F logs \"\u003Cp\u003EHello\u003C\u002Fp\u003E\"\n```\n\n## Other noteworthy features\n\n### Canvas support\n\njsdom includes support for using the [`canvas`](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fcanvas) or [`canvas-prebuilt`](https:\u002F\u002Fnpmjs.org\u002Fpackage\u002Fcanvas-prebuilt) package to extend any `\u003Ccanvas\u003E` elements with the canvas API. To make this work, you need to include `canvas` as a dependency in your project, as a peer of `jsdom`. If jsdom can find the `canvas` package, it will use it, but if it's not present, then `\u003Ccanvas\u003E` elements will behave like `\u003Cdiv\u003E`s.\n\n### Encoding sniffing\n\nIn addition to supplying a string, the `JSDOM` constructor can also be supplied binary data, in the form of a Node.js [`Buffer`](https:\u002F\u002Fnodejs.org\u002Fdocs\u002Flatest\u002Fapi\u002Fbuffer.html) or a standard JavaScript binary data type like `ArrayBuffer`, `Uint8Array`, `DataView`, etc. When this is done, jsdom will [sniff the encoding](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fsyntax.html#encoding-sniffing-algorithm) from the supplied bytes, scanning for `\u003Cmeta charset\u003E` tags just like a browser does.\n\nThis encoding sniffing also applies to `JSDOM.fromFile()` and `JSDOM.fromURL()`. In the latter case, just as in a browser, any `Content-Type` headers sent with the response will take priority.\n\nNote that in many cases supplying bytes in this fashion can be better than supplying a string. For example, if you attempt to use Node.js's `buffer.toString(\"utf-8\")` API, Node.js will not strip any leading BOMs. If you then give this string to jsdom, it will interpret it verbatim, leaving the BOM intact. But jsdom's binary data decoding code will strip leading BOMs, just like a browser; in such cases, supplying `buffer` directly will give the desired result.\n\n### Closing down a jsdom\n\nTimers in the jsdom (set by `window.setTimeout()` or `window.setInterval()`) will, by definition, execute code in the future in the context of the window. Since there is no way to execute code in the future without keeping the process alive, outstanding jsdom timers will keep your Node.js process alive. Similarly, since there is no way to execute code in the context of an object without keeping that object alive, outstanding jsdom timers will prevent garbage collection of the window on which they are scheduled.\n\nIf you want to be sure to shut down a jsdom window, use `window.close()`, which will terminate all running timers (and also remove any event listeners on the window and document).\n\n### Running jsdom inside a web browser\n\njsdom has some support for being run inside a web browser, using [browserify](https:\u002F\u002Fbrowserify.org\u002F). That is, inside a web browser, you can use a browserified jsdom to create an entirely self-contained set of plain JavaScript objects which look and act much like the browser's existing DOM objects, while being entirely independent of them. \"Virtual DOM\", indeed!\n\njsdom's primary target is still Node.js, and so we use language features that are only present in recent Node.js versions (namely, Node.js v6+). Thus, older browsers will likely not work. (Even transpilation will not help much: we plan to use `Proxy`s extensively throughout the course of jsdom v10.x.)\n\nNotably, jsdom works well inside a web worker. The original contributor, [@lawnsea](https:\u002F\u002Fgithub.com\u002Flawnsea\u002F), who made this possible, has [published a paper](https:\u002F\u002Fpdfs.semanticscholar.org\u002F47f0\u002F6bb6607a975500a30e9e52d7c9fbc0034e27.pdf) about his project which uses this capability.\n\nNot everything works perfectly when running jsdom inside a web browser. Sometimes that is because of fundamental limitations (such as not having filesystem access), but sometimes it is simply because we haven't spent enough time making the appropriate small tweaks. Bug reports are certainly welcome.\n\n### Debugging the DOM using Chrome Devtools\n\nAs of Node.js v6 you can debug programs using Chrome Devtools. See the [official documentation](https:\u002F\u002Fnodejs.org\u002Fen\u002Fdocs\u002Finspector\u002F) for how to get started.\n\nBy default jsdom elements are formatted as plain old JS objects in the console. To make it easier to debug, you can use [jsdom-devtools-formatter](https:\u002F\u002Fgithub.com\u002Fviddo\u002Fjsdom-devtools-formatter), which lets you inspect them like real DOM elements.\n\n## Caveats\n\n### Asynchronous script loading\n\nPeople often have trouble with asynchronous script loading when using jsdom. Many pages loads scripts asynchronously, but there is no way to tell when they're done doing so, and thus when it's a good time to run your code and inspect the resulting DOM structure. This is a fundamental limitation; we cannot predict what scripts on the web page will do, and so cannot tell you when they are done loading more scripts.\n\nThis can be worked around in a few ways. The best way, if you control the page in question, is to use whatever mechanisms are given by the script loader to detect when loading is done. For example, if you're using a module loader like RequireJS, the code could look like:\n\n```js\n\u002F\u002F On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () =\u003E {\n  console.log(\"ready to roll!\");\n};\n```\n\n```html\n\u003C!-- Inside the HTML you supply to jsdom --\u003E\n\u003Cscript\u003E\nrequirejs([\"entry-module\"], () =\u003E {\n  window.onModulesLoaded();\n});\n\u003C\u002Fscript\u003E\n```\n\nIf you do not control the page, you could try workarounds such as polling for the presence of a specific element.\n\nFor more details, see the discussion in [#640](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues\u002F640), especially [@matthewkastor](https:\u002F\u002Fgithub.com\u002Fmatthewkastor)'s [insightful comment](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues\u002F640#issuecomment-22216965).\n\n### Shared constructors and prototypes\n\nAt the present time, for most web platform APIs, jsdom shares the same class definition between multiple seemingly-independent jsdoms. That means that, for example, the following situation can occur:\n\n```js\nconst dom1 = new JSDOM();\nconst dom2 = new JSDOM();\n\ndom1.window.Element.prototype.expando = \"blah\";\nconsole.log(dom2.window.document.createElement(\"frameset\").expando); \u002F\u002F logs \"blah\"\n```\n\nThis is done mainly for performance and memory reasons: creating separate copies of all the many classes on the web platform, each time we create a jsdom, would be rather expensive.\n\nNevertheless, we remain interested in one day providing an option to create an \"independent\" jsdom, at the cost of some performance.\n\n### Missing features in the new API\n\nCompared to the old jsdom API from v9.x and before, the new API is noticeably missing fine-grained control of resource loads. Previous versions of jsdom allowed you to set options that were used when making requests (both for the initial request, in the old equivalent of `JSDOM.fromURL()`, and for subresource requests). They also allowed you to control which subresources were requested and applied to the main document, so that you could e.g. download stylesheets but not scripts. Finally, they provided a customizable resource loader that let you intercept any outgoing request and fulfill it with a completely synthetic response.\n\nNone of these features are yet in the new jsdom API, although we are hoping to add them back soon! This requires a decent amount of behind-the-scenes work to implement in a reasonable way, unfortunately.\n\nIn the meantime, please feel free to use the old jsdom API to get access to this functionality. It is supported and maintained, although it will not be getting new features. The documentation is found in [lib\u002Fold-api.md](.\u002Flib\u002Fold-api.md).\n\n### Unimplemented parts of the web platform\n\nAlthough we enjoy adding new features to jsdom and keeping it up to date with the latest web specs, it has many missing APIs. Please feel free to file an issue for anything missing, but we're a small and busy team, so a pull request might work even better.\n\nBeyond just features that we haven't gotten to yet, there are two major features that are currently outside the scope of jsdom. These are:\n\n- **Navigation**: the ability to change the global object, and all other objects, when clicking a link or assigning `location.href` or similar.\n- **Layout**: the ability to calculate where elements will be visually laid out as a result of CSS, which impacts methods like `getBoundingClientRects()` or properties like `offsetTop`.\n\nCurrently jsdom has dummy behaviors for some aspects of these features, such as sending a \"not implemented\" `\"jsdomError\"` to the virtual console for navigation, or returning zeros for many layout-related properties. Often you can work around these limitations in your code, e.g. by creating new `JSDOM` instances for each page you \"navigate\" to during a crawl, or using `Object.defineProperty()` to change what various layout-related getters and methods return.\n\nNote that other tools in the same space, such as PhantomJS, do support these features. On the wiki, we have a more complete writeup about [jsdom vs. PhantomJS](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fwiki\u002Fjsdom-vs.-PhantomJS).\n\n## Getting help\n\nIf you need help with jsdom, please feel free to use any of the following venues:\n\n- The [mailing list](http:\u002F\u002Fgroups.google.com\u002Fgroup\u002Fjsdom) (best for \"how do I\" questions)\n- The [issue tracker](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues) (best for bug reports)\n- The IRC channel: [#jsdom on freenode](irc:\u002F\u002Firc.freenode.net\u002Fjsdom)\n",
    "0b402d1f88fcadf701e3ddbdc5faa5473b6f3118::files\u002Fzh-cn\u002Fgithub\u002Fjsdom.md": "\u003Ch1 align=\"center\"\u003E\n    \u003Cimg width=\"100\" height=\"111\" src=\"https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fraw\u002Fmaster\u002Flogo.svg\" alt=\"\"\u003E\u003Cbr\u003E\n    jsdom\n\u003C\u002Fh1\u003E\n\njsdom是一个纯粹由 javascript 实现的一系列 web标准，特别是 WHATWG 组织制定的[DOM](https:\u002F\u002Fdom.spec.whatwg.org\u002F)和 [HTML](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002F) 标准，用于在 nodejs 中使用。大体上来说，该项目的目标是模拟足够的Web浏览器子集，以便用于测试和挖掘真实世界的Web应用程序。\n\n最新版本的 jsdom 运行环境需要 node.js v6或者更高的版本。（jsdom v10以下版本在 nodejs v4以下仍然可用，但是我们已经不支持维护了）\n\nv10版本的 jsdom 拥有全新的 API(如下所述).旧的 API 现在仍然支持;[详细的参照文档](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fblob\u002Fmaster\u002Flib\u002Fold-api.md)\n\n## 基本用法\n```js\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n```\n为了使用 jsdom，主要用到jsdom主模块的一个命名导出的 `jsdom` 构造函数。往构造器传递一个字符串，将会得到一个 jsdom 构造实例对象，这个对象有很多实用的属性，特别是 `window` 对象:\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003E\u003Cp\u003EHello world\u003C\u002Fp\u003E`);\nconsole.log(dom.window.document.querySelector(\"p\").textContent); \u002F\u002F \"Hello world\"\n```\n(请注意，jsdom会像浏览器一样解析您传递的HTML，包括隐含的`\u003Chtml\u003E`，`\u003Chead\u003E`和`\u003Cbody\u003E`标记)\n\n生成的对象是JSDOM类的一个实例，其中包括 `window` 对象在内的许多有用的属性和方法。一般来说，它可以用来从“外部”对jsdom进行操作，而这些操作对于普通DOM API来说是不可能的。对于不需要任何功能的简单场景，我们推荐使用类似的编码模式\n\n```js\nconst { window } = new JSDOM(`...`);\n\u002F\u002F or even\nconst { document } = (new JSDOM(`...`)).window;\n```\n\n下面是关于JSDOM类所能做的一切的完整文档，在“JSDOM对象API”部分。\n\n## 定制 jsdom\n\nJSDOM构造函数接受第二个参数，可以用以下方式定制您的jsdom。\n\n### 简单选项\n```js\nconst dom = new JSDOM(``, {\n  url: \"https:\u002F\u002Fexample.org\u002F\",\n  referrer: \"https:\u002F\u002Fexample.com\u002F\",\n  contentType: \"text\u002Fhtml\",\n  userAgent: \"Mellblomenator\u002F9000\",\n  includeNodeLocations: true\n});\n```\n\n- `url` 设置的值可以通过`window.location`，`document.URL`和`document.documentURI`来返回，并会影响文档中相关URL的解析以及获取子资源时使用的同源限制和referrer。默认值为`\"about:blank\"`。\n- `referrer` 仅仅影响`document.referrer`的值。默认没有引用（即为空字符串）。\n- `contentType` 影响`document.contentType`的值，是按照HTML解析文档还是 XML来解析。它的值如果不是`text\u002Fhtml`或[`XML mime type`](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Finfrastructure.html#xml-mime-type) 值的话将会抛出异常。默认值为`\"text\u002Fhtml\"`。\n- `userAgent` 影响`navigator.userAgent`的值以及请求子资源时发送的`User-Agent`头。默认值为`Mozilla \u002F 5.0（$ {process.platform}）AppleWebKit \u002F 537.36（KHTML，如Gecko）jsdom \u002F $ {jsdomVersion}`。\n- includeNodeLocations 保留由HTML解析器生成的位置信息，允许您使用`nodeLocation()`方法（如下所述）检索它。\n它还能确保在`\u003Cscript\u003E`元素内运行的代码的异常堆栈跟踪中报告的行号是正确的。\n默认值为`false`以提供最佳性能，并且不能与XML内容类型一起使用，因为我们的XML解析器不支持位置信息。\n\n**请注意**，`url` 和```referrer```在使用之前已经被规范化了，例如\n如果你传入`\"https:example.com\"`，jsdom会自动规范化解释为`\"https:\u002F\u002Fexample.com\u002F\"`。\n如果你传递了一个不可解析的URL，该调用将抛出错误。\n（URL根据[URL标准](http:\u002F\u002Furl.spec.whatwg.org\u002F)进行分析和序列化。）\n\n\n### 执行脚本\n\njsdom最强大的功能是它可以在jsdom中执行脚本。这些脚本可以修改页面的内容并访问jsdom实现的所有Web平台API。\n\n但是，这在处理不可信内容时也非常危险。\njsdom沙箱并不是万无一失的，在DOM的`\u003Cscript\u003E`内部运行的代码如果足够深入，就可以访问Node.js环境，从而访问您的计算机。\n因此，默认情况下，执行嵌入在HTML中的脚本的功能是禁用的：\n\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`);\n\n\u002F\u002F 脚本默认将不能执行:\ndom.window.document.body.children.length === 1;\n```\n\n要在页面内启用脚本，可以使用`runScripts:\"dangerously\"`选项：\n```js\nconst dom = new JSDOM(`\u003Cbody\u003E\n  \u003Cscript\u003Edocument.body.appendChild(document.createElement(\"hr\"));\u003C\u002Fscript\u003E\n\u003C\u002Fbody\u003E`, { runScripts: \"dangerously\" });\n\n\u002F\u002F 脚本将执行并修改 DOM:\ndom.window.document.body.children.length === 2;\n```\n\n我们再次强调只有在提供给jsdom的代码是你已知道是安全的代码时方可使用它。如果您运行了任意用户提供的或Internet上的不可信的Node.js代码，可能会危及您的计算机。\n\n假如你想通过`\u003Cscript src=\"\"\u003E`来执行外部脚本，你需要确保已经加载了它们。为此，请添加选项`resources:\"usable\"` [如下所述](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom#loading-subresources)。\n\n**请注意**，除非`runScripts`设置为`\"dangerously\"`，否则事件处理程序属性（如`\u003Cdiv onclick =“”\u003E`）也将不起作用。（但是，事件处理函数属性，比如`div.onclick = ...`，将无视`runScripts`参数 并且会起作用）\n\n如果您只是试图从“外部”执行脚本，而不是通过`\u003Cscript\u003E`元素（和内联事件处理程序）从内部运行“，则可以使用`runScripts: \"outside-only\"`选项，该选项会启用`window.eval`：\n\n```js\nconst window = (new JSDOM(``, { runScripts: \"outside-only\" })).window;\n\nwindow.eval(`document.body.innerHTML = \"\u003Cp\u003EHello, world!\u003C\u002Fp\u003E\";`);\nwindow.document.body.children.length === 1;\n```\n由于性能原因，默认情况下会关闭此功能，但可以安全启用。\n\n**请注意**，我们强烈建议不要试图通过将jsdom和Node全局环境混合在一起（例如，通过执行global.window = dom.window）来“执行脚本”，然后在Node全局环境中执行脚本或测试代码。相反，您应该像对待浏览器一样对待jsdom，并使用`window.eval`或`runScripts: \"dangerously\"`来运行需要访问jsdom环境内的DOM的所有脚本和测试。例如，这可能需要创建一个browserify包作为`\u003Cscript\u003E`元素执行 - 就像在浏览器中一样。\n\n最后，对于高级用例，您可以使用dom.runVMScript（脚本）方法，如下所述。\n\n### 假装成一个视觉浏览器\njsdom没有渲染可视内容的能力，并且默认情况下会像无头浏览器一样工作。它通过API（如document.hidden）向网页提供提示，表明其内容不可见。\n\n当`pretendToBeVisual`选项设置为true时，jsdom会假装它正在呈现并显示内容。它是这样做的：\n- 更改`document.hidden`以返回false而不是true\n- 更改`document.visibilityState`以返回“visible”而不是“prerender”\n- 启用`window.requestAnimationFrame()` 和`window.cancelAnimationFrame()`方法，否则不存在\n\n```js\nconst window = (new JSDOM(``, { pretendToBeVisual: true })).window;\n\nwindow.requestAnimationFrame(timestamp =\u003E {\n  console.log(timestamp \u003E 0);\n});\n```\n\n**请注意**，jsdom仍然[不做任何布局或渲染](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom#unimplemented-parts-of-the-web-platform)，因此这实际上只是假装为可视化，而不是实现真正的可视化Web浏览器将实现的部分。\n\n### 加载子资源\n\n默认情况下，jsdom不会加载任何子资源，如脚本，样式表，图像或iframe。如果您希望jsdom加载这些资源，则可以传递`resources: \"usable\"`选项，该选项将加载所有可用资源。资源列表如下：\n-  frame 和 iframe,通过 `\u003Cframe\u003E` 和 `\u003Ciframe\u003E`实现\n-  样式，通过`\u003Clink rel=\"stylesheet\"\u003E`\n-  脚本，通过`\u003Cscript\u003E`,但是前提是`runScripts: \"dangerously\"`设置了\n-  图片，通过`\u003Cimg\u003E`,但是前提是[`canvas`](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fcanvas)(或者 [`canvas-prebuilt`](https:\u002F\u002Fnpmjs.org\u002Fpackage\u002Fcanvas-prebuilt)) npm  包已安装\n\n未来，我们计划通过此选项提供更多的资源加载定制，但现在只提供的两种模式：`'default'`和 `'usable'`。\n\n### 虚拟控制台\n\n像网页浏览器一样，jsdom也具有“控制台”的概念。通过在文档内执行的脚本以及来自jsdom本身实现的信息和记录会从页面直接发送过来。我们将用户可控制的控制台称为“虚拟控制台”，以便将其与Node.js console API和页面内部的window.console API区分开来。\n\n默认情况下，JSDOM构造函数将返回一个具有虚拟控制台的实例，该虚拟控制台将其所有输出转发到Node.js控制台。为了创建自己的虚拟控制台并将其传递给jsdom，可以通过执行下面代码来覆盖此默认值\n```js\nconst virtualConsole = new jsdom.VirtualConsole();\nconst dom = new JSDOM(``, { virtualConsole });\n```\n这样的代码将创建一个没有任何行为的虚拟控制台。您可以为所有可能的控制台方法添加事件侦听器来为其提供行为：\n```js\nvirtualConsole.on(\"error\", () =\u003E { ... });\nvirtualConsole.on(\"warn\", () =\u003E { ... });\nvirtualConsole.on(\"info\", () =\u003E { ... });\nvirtualConsole.on(\"dir\", () =\u003E { ... });\n\u002F\u002F ... etc. See https:\u002F\u002Fconsole.spec.whatwg.org\u002F#logging\n```\n\n（**请注意**，最好在调用 `new JSDOM()`之前设置这些事件侦听器，因为在解析期间可能会发生错误或控制台调用脚本错误。）\n\n如果你只是想将虚拟控制台输出重定向到另一个控制台，比如默认的Node.js，你可以这样做\n```js\nvirtualConsole.sendTo(console);\n```\n\n还有一个特殊的事件，`\"jsdomError\"`，它的触发将通过错误对象来记录jsdom本身的错误。这与错误消息在Web浏览器控制台中的显示方式类似，即使它们不是由console.error输出的。到目前为止，错误会按照下面的方式输出：\n\n- 加载或解析子资源时出错（脚本，样式表，frames和iframe）\n- 不是由`window onerror`事件处理程序处理的脚本执行错误，它将会返回true或调用event.preventDefault()\n- 由于调用jsdom没有实现的方法而导致的错误，例如window.alert，兼容性的 web 浏览器都实现了这些方法\n\n如果您使用`sendTo(c)`将错误发送给c，则默认情况下，它将使用来自`\"jsdomError\"`事件的信息调用console.error。如果您希望保持事件与方法调用的严格的一对一映射，并且可能自己处理`\"jsdomError\"`，那么您可以执行\n```js\nvirtualConsole.sendTo(c, { omitJSDOMErrors: true });\n```\n\n### Cookie jars(存储Cookie的容器)\n像网页浏览器一样，jsdom也具有cookie jar的概念，存储HTTP cookie 。在文档的同一个域上一个URL，并且没有标记为`HTTP only`的cookies,可以通过`document.cookie` API来访问。此外，Cookie jar中的所有cookie都会影响子资源的http加载。\n\n默认情况下，JSDOM构造函数将返回一个带有空cookie的实例。要创建自己的cookie jar并将其传递给jsdom，可以通过以下代码来覆盖默认值\n\n```js\nconst cookieJar = new jsdom.CookieJar(store, options);\nconst dom = new JSDOM(``, { cookieJar });\n```\n\n如果您想要在多个jsdoms中共享同一个cookie jar，或者提前使用特定的值来填充cookie jar，这将非常有用。\n\nCookie jar包由[tough-cookie](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Ftough-cookie)包提供的。`jsdom.CookieJar`构造函数是`tough-cookie cookie jar`的子类，并且默认设置了`looseMode：true`选项，因为它[更符合浏览器的行为方式](https:\u002F\u002Fgithub.com\u002Fwhatwg\u002Fhtml\u002Fissues\u002F804)。如果您想自己使用`tough-cookie`的方法和类，则可以使用`jsdom.toughCookie`模块导出来访问使用jsdom打包的`tough-cookie`模块实例。\n\n### 在解析之前进行干预\n\njsdom允许您在很早的时候介入创建jsdom：**创建Window和Document对象之后，但在解析任何HTML并使用节点填充文档之前**：\n```js\nconst dom = new JSDOM(`\u003Cp\u003EHello\u003C\u002Fp\u003E`, {\n  beforeParse(window) {\n    window.document.childNodes.length === 0;\n    window.someCoolAPI = () =\u003E { \u002F* ... *\u002F };\n  }\n});\n```\n如果您希望以某种方式修改环境，这尤其有用，例如添加jsdom不支持的Web API的填充程序。\n\n## JSDOM object API\n一旦你构建了一个JSDOM对象，它将具有以下有用的功能：\n\n### Properties\n`window`属性: `window`对象的key 从`Window` 对象检索而来\n`virtualConsole`和`cookieJar`：可以传入或者使用默认值\n\n### 通过`serialize()`序列化document\n```js\nconst dom = new JSDOM(`\u003C!DOCTYPE html\u003Ehello`);\n\ndom.serialize() === \"\u003C!DOCTYPE html\u003E\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n\n\u002F\u002F Contrast with:\ndom.window.document.documentElement.outerHTML === \"\u003Chtml\u003E\u003Chead\u003E\u003C\u002Fhead\u003E\u003Cbody\u003Ehello\u003C\u002Fbody\u003E\u003C\u002Fhtml\u003E\";\n```\n\n### 通过`nodeLocation(node)`获取 dom 节点的源位置信息\n`nodeLocation()`方法将查找DOM节点在源文档中的位置，并返回节点的[parse5位置信息](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fparse5#options-locationinfo)：\n```js\nconst dom = new JSDOM(\n  `\u003Cp\u003EHello\n    \u003Cimg src=\"foo.jpg\"\u003E\n  \u003C\u002Fp\u003E`,\n  { includeNodeLocations: true }\n);\n\nconst document = dom.window.document;\nconst bodyEl = document.body; \u002F\u002F implicitly created\nconst pEl = document.querySelector(\"p\");\nconst textNode = pEl.firstChild;\nconst imgEl = document.querySelector(\"img\");\n\nconsole.log(dom.nodeLocation(bodyEl));   \u002F\u002F null; it's not in the source\nconsole.log(dom.nodeLocation(pEl));      \u002F\u002F { startOffset: 0, endOffset: 39, startTag: ..., endTag: ... }\nconsole.log(dom.nodeLocation(textNode)); \u002F\u002F { startOffset: 3, endOffset: 13 }\nconsole.log(dom.nodeLocation(imgEl));    \u002F\u002F { startOffset: 13, endOffset: 32 }\n```\n**请注意**，只有您设置了`includeNodeLocations`选项才能使用此功能;由于性能原因，节点位置默认为关闭。\n\n\n### 使用`runVMScript(script)`运行vm创建的脚本\n\nNode.js的内置vm模块允许您创建`Script`实例，这些脚本实例可以提前编译，然后在给定的“VM上下文”上运行多次。在这个场景背后，jsdom `Window`是一个确定的VM上下文。要访问此功能，请使用`runVMScript()`方法：\n\n```js\nconst { Script } = require(\"vm\");\n\nconst dom = new JSDOM(``, { runScripts: \"outside-only\" });\nconst s = new Script(`\n  if (!this.ran) {\n    this.ran = 0;\n  }\n\n  ++this.ran;\n`);\n\ndom.runVMScript(s);\ndom.runVMScript(s);\ndom.runVMScript(s);\n\ndom.window.ran === 3;\n```\n\n这是高级功能，除非您有特殊的需求，否则我们建议坚持使用普通的DOM API（如window.eval（）或document.createElement（“script”））。\n\n### 通过`reconfigure(settings)`重新配置jsdom\n\n`window.top`属性在规范中被标记为[Unforgeable][中文：伪造的]，这意味着它是一个不可配置的私有属性，因此在jsdom内运行的普通代码是不能覆盖或遮挡它的，即使使用`Object.defineProperty`。\n\n同样，目前在jsdom中是不能够处理`navigation`相关信息的（比如设置`window.location.href =\"https:\u002F\u002Fexample.com\u002F\"`）;这样做会导致虚拟控制台发出`\"jsdomError\"`，说明此功能未实现，并且没有任何变化,也将不会有新的`Window`或`Document`对象，并且现有`window.location`对象仍保持当前所有相同的属性值。\n\n但是，如果您从 jsdom 窗口之外进行演示，例如在一些创建jsdoms的测试框架中，可以使用特殊的`reconfigure()`方法覆盖其中的一个或两个：\n```js\nconst dom = new JSDOM();\n\ndom.window.top === dom.window;\ndom.window.location.href === \"about:blank\";\n\ndom.reconfigure({ windowTop: myFakeTopForTesting, url: \"https:\u002F\u002Fexample.com\u002F\" });\n\ndom.window.top === myFakeTopForTesting;\ndom.window.location.href === \"https:\u002F\u002Fexample.com\u002F\";\n```\n\n**请注意**，更改jsdom的URL将影响所有返回当前 document URL的API，例如`window.location`，`document.URL``和document.documentURI`，以及文档中相对URL的解析以及同源检查和提取子资源时使用的引用。但是，它不会执行导航到该URL的内容;DOM的内容将保持不变，并且不会创建`Window`，`Document`等新的实例。\n\n\n## 便捷的 APIs\n\n### `fromURL()`\n\n除了JSDOM构造函数本身之外，jsdom还提供了一个返回 `Promise` 的工厂方法，用于通过URL构建一个jsdom实例\n```js\nJSDOM.fromURL(\"https:\u002F\u002Fexample.com\u002F\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\n如果URL有效且请求成功，则`onFullfilled`回调执行并返回JSDOM实例。任何URL重定向都将遵循其最终目的地。\n\n`fromURL()`提供的参数选项与提供给JSDOM构造函数的选项类似，但具有以下额外的限制和后果：\n- `url` 和 `contentType` 参数不能被提供\n- `referrer` 选项用作初始请求的HTTP Referer请求头\n- `userAgent` 选项用作任何请求的HTTP User-Agent请求头\n- 生成的jsdom的`url` 和 `contentType`和`referrer`是 由 http response来决定\n- 任何通过HTTP Set-Cookie响应头设置的cookie都存储在jsdom的cookie jar中。同样，已提供的cookie jar中的任何cookie都会作为HTTP Cookie请求标头发送。\n\n初始的请求并不能无限定制到像[request](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Frequest) npm 包一样的程度;`fromURL()`旨在为大多数情况提供便利的API。如果您需要更好地控制初始请求，您应该自己执行它，然后手动使用JSDOM构造函数。\n\n### `fromFile()`\n\n与`fromURL()`类似，jsdom还提供了一个`fromFile()`工厂方法，用于从文件名构建jsdom\n```js\nJSDOM.fromFile(\"stuff.html\", options).then(dom =\u003E {\n  console.log(dom.serialize());\n});\n```\n\n如果可以打开给定的文件，则`onFullfilled`回调执行并返回JSDOM实例。和Node.js API一样，文件名是相对于当前工作目录的。\n\n`fromFile()`提供的选项与提供给JSDOM构造函数的选项相似，但具有以下额外的默认值：\n\n- `url`选项将默认为给定文件名相对应的文件URL，而不是`\"about：blank\"`\n- 假如给定的文件名是以`.xhtml`或者`.xml`为后缀的话，`contentType`选项默认为`\"application\u002Fxhtml+xml\"`;反之为`\"text\u002Fhtml\"`。\n\n\n### `fragment()`\n\n对于最简单的情况，你可能不需要一个完整的JSDOM实例及其所有相关的功能。您甚至可能不需要`Window`或`Document`！相反，你只需要解析一些HTML片段，并获得一个你可以操作的`DOM`对象。为此，我们提供了`fragment()`，它可以从给定的字符串中创建一个`DocumentFragment`：\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EHi!\u003C\u002Fstrong\u003E`);\n\nfrag.childNodes.length === 2;\nfrag.querySelector(\"strong\").textContent = \"Why hello there!\";\n\u002F\u002F etc.\n```\n\n`frag`是`DocumentFragment`的实例对象，其内容是通过提供的字符串解析创建的。解析是通过使用`\u003Ctemplate\u003E`元素完成的，因此您可以在其中包含任何元素（包括具有奇怪解析规则的元素，如`\u003Ctd\u003E`）。\n\n`fragment()`工厂函数的所有调用结果的`DocumentFragments`实例都会共享相同的`Document`和`Window`。这允许多次调用`fragment()`而没有额外的开销。但这也意味着对`fragment()`的调用不能用任何选项自定义。\n\n**请注意**，对`DocumentFragments`的序列化并不像使用JSDOM对象那样容易。如果你需要序列化你的`DOM`，你应该直接使用JSDOM构造函数。但对于包含单个元素的片段的特殊情况，通过常规方法就很容易做到。\n\n```js\nconst frag = JSDOM.fragment(`\u003Cp\u003EHello\u003C\u002Fp\u003E`);\nconsole.log(frag.firstChild.outerHTML); \u002F\u002F logs \"\u003Cp\u003EHello\u003C\u002Fp\u003E\"\n```\n\n## 其他值得注意的功能\n\n### 支持 Canvas\njsdom支持使用[canvas](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fcanvas)或[canvas-prebuilt](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fcanvas-prebuilt)包来扩展任何使用canvas API的`\u003Ccanvas\u003E`元素。为了做到这一点，您需要将`canvas`作为依赖项加入到您的项目中，和 `jsdom`包并列。如果jsdom可以找到`canvas`包，它将使用它，但是如果它不存在，那么`\u003Ccanvas\u003E`元素的行为就像`\u003Cdiv\u003E`一样。\n\n### 编码嗅探\n\n除了提供一个字符串外，JSDOM构造函数还支持Node.js  [`Buffer`](https:\u002F\u002Fnodejs.org\u002Fdocs\u002Flatest\u002Fapi\u002Fbuffer.html)或标准JavaScript二进制数据类型（如ArrayBuffer，Uint8Array，DataView等）的形式提供二进制数据。当完成后，jsdom将从提供的字节进行[`嗅探编码`](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fsyntax.html#encoding-sniffing-algorithm)，就像浏览器扫描`\u003Cmeta charset\u003E`标签一样。\n\n这种编码嗅探也适用于`JSDOM.fromFile()`和`JSDOM.fromURL()`。在后一种情况下，就像在浏览器中一样，任何与response响应一起发送的`Content-Type`头信息优先级更高。\n\n**请注意**，在许多情况下，提供字节这种方式可能比提供字符串更好。例如，如果您试图使用Node.js的`buffer.toString('utf-8')`API，则Node.js将不会去除任何前导BOM。如果您将此字符串提供给jsdom，它会逐字解释，从而使BOM保持不变。但jsdom的二进制数据解码代码将剥离前导的BOM，就像浏览器一样;在这种情况下，直接提供`buffer`将会得到想要的结果。\n\n### 关闭一个jsdom\n\njsdom中定义的定时器（通过`window.setTimeout`或`window.setInterval`设置）将在window上下文中执行代码。由于进程在不活跃的情况下无法执行未来的定时器代码，所以卓越的jsdom定时器将保持您的Node.js进程处于活动状态。同样，对象不活跃的情况下也没有办法在对象的上下文中执行代码，卓越的jsdom定时器将阻止垃圾回收调度它们的window。\n\n如果你想确保关闭jsdom窗口，使用`window.close()`，它将终止所有正在运行的定时器（并且还会删除 `window`和`document`上的任何事件监听器）。\n\n### 在Web浏览器中运行jsdom\n\n使用[browserify](http:\u002F\u002Fbrowserify.org\u002F)模块，jsdom某些方面也支持在Web浏览器中运行。也就是说，在Web浏览器中，您可以使用被`browserify`模块编译过的jsdom去创建完全独立的普通JavaScript对象集，其外观和行为与浏览器的现有DOM对象非常相似，但完全独立于它们，也就是\"虚拟DOM\"！\n\njsdom的主要目标对象仍然是Node.js，因此我们使用仅存在于最新Node.js版本（即Node.js v6 +）中的语言特性功能。因此，在旧版浏览器可能无法正常工作。（即使编译也不会有多大帮助：我们计划在jsdom v10.x的整个过程中广泛使用`Proxy`。）\n\n值得注意的是，jsdom在`web worker`中能很好的运行。项目的开发者[@lawnsea](https:\u002F\u002Fgithub.com\u002Flawnsea\u002F)使这一功能点成为可能，他发表了一篇关于他的[项目的论文](https:\u002F\u002Fpdfs.semanticscholar.org\u002F47f0\u002F6bb6607a975500a30e9e52d7c9fbc0034e27.pdf)，该论文就使用了这种能力。\n\n在Web浏览器中运行jsdom时，并非所有的工作都完美。有些情况下，这是由于基础的条件限制（比如没有文件系统访问），但有些情况下也是因为我们没有花足够的时间去进行适当的小调整。欢迎大家来提BUG。\n\n### 使用Chrome Devtools调试DOM\n\n从Node.js v6开始，您可以使用Chrome Devtools来调试程序。请参阅[官方文档](https:\u002F\u002Fnodejs.org\u002Fen\u002Fdocs\u002Fguides\u002Fdebugging-getting-started\u002F)了解如何使用。\n\n默认情况下，jsdom元素在控制台中被格式化为普通的旧JS对象。为了便于调试，可以使用[jsdom-devtools-formatter](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom-devtools-formatter)，它可以让你像真正的DOM元素一样调试它们。\n\n## 注意事项\n\n### 异步脚本加载\n\n使用jsdom时，开发者在加载异步脚本时经常遇到麻烦。许多页面异步加载脚本，但无法分辨脚本什么时候完成，因此无法知道何时是运行代码并检查生成的DOM结构的好时机。这是一个基本的限制;我们无法预测网页上的哪些脚本会做什么，因此无法告诉您脚本何时加载完毕。\n\n这个问题可以通过几种方法来解决。如果您能控制页面逻辑，最好的方法是使用脚本加载器提供的机制来检测何时加载完成。例如，如果您使用像RequireJS这样的模块加载器，代码可能如下所示：\n```js\n\u002F\u002F On the Node.js side:\nconst window = (new JSDOM(...)).window;\nwindow.onModulesLoaded = () =\u003E {\n  console.log(\"ready to roll!\");\n};\n```\n\n```js\n\u003C!-- Inside the HTML you supply to jsdom --\u003E\n\u003Cscript\u003E\nrequirejs([\"entry-module\"], () =\u003E {\n  window.onModulesLoaded();\n});\n\u003C\u002Fscript\u003E\n```\n\n如果您不能控制该页面，则可以尝试其他解决方法，例如轮询检查特定元素是否存在。有关更多详细信息，请查看[#640](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues\u002F640)中的讨论，尤其是[@ matthewkastor](https:\u002F\u002Fgithub.com\u002Fmatthewkastor)的[深刻见解](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues\u002F640#issuecomment-22216965)。\n\n### 共享的构造函数和原型\n\n目前，对于大多数Web平台API，jsdom在多个看似独立的jsdoms之间共享相同的类定义。这将意味着，可能会出现以下情况\n```js\nconst dom1 = new JSDOM();\nconst dom2 = new JSDOM();\n\ndom1.window.Element.prototype.expando = \"blah\";\nconsole.log(dom2.window.document.createElement(\"frameset\").expando); \u002F\u002F logs \"blah\"\n```\n\n这主要是出于性能和内存的原因：如果在Web平台上每次创建jsdom时,创建所有类的单独副本，开销将会相当昂贵。\n\n尽管如此，我们仍然有兴趣在有一天提供一个选项配置来创建一个“独立”的jsdom，但要牺牲一些性能。\n\n### 新API中缺失的功能\n\n与v9.x之前的旧版jsdom API相比，新API显然缺少对资源加载的精细控制。先前版本的jsdom允许您设置request时使用的选项（既可以用于初始请求，也可以用于旧版本的`JSDOM.fromURL()`和子资源请求）。他们还允许您控制请求哪些子资源并将其应用于主文档，以便您可以下载样式表，但不下载脚本文件。最后，他们提供了一个可定制的资源加载器，可以拦截任何传出的请求并用完全合成的response 响应来结束。\n\n以上这些功能尚未在新的jsdom API中实现，尽管我们也希望尽快将它们添加回来，但不幸的是，这需要相当大的幕后工作去实施。\n\n同时，请随时使用旧的jsdom API来访问此功能。它一直处于支持和维护中，但它不会获得新功能。旧的文档位于[`lib\u002Fold-api.md`](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fblob\u002Fmaster\u002Flib\u002Fold-api.md)中。\n\n### 未实现的Web平台部分\n\n目前jsdom中有很多缺失的API，尽管我们也想要在jsdom中添加新的功能并保持最新的Web规范。请随时为缺失的任何内容提交issue，但我们是一个很小并且忙碌的团队，因此大家一起来提交 pull request可能会更好。\n\n除了我们尚未拥有的功能之外，还有两个主要功能目前超出了jsdom的范围。这些是：\n- Navigation：在点击链接或赋值location.href或类似操作时可以更改全局对象和所有其他的对象。\n- Layout：计算CSS元素的视觉布局的能力，这会影响诸如`getBoundingClientRects()`或者诸如`offsetTop`之类的属性\n\n目前，jsdom对某些功能的某些方面具有虚拟行为，例如操作`navigation` 时向虚拟控制台发送“未实现的”`\"jsdomError\"`，或者为许多与布局相关的属性返回0。您通常可以在代码中解决这些限制，例如通过在爬网过程中为每个页面创建新的JSDOM实例，或使用`Object.defineProperty`更改各种与布局相关的`getter`和方法的返回值\n\n**请注意**，相同领域中的其他工具（如PhantomJS）确实支持这些功能。在wiki上，我们有关于[jsdom vs. PhantomJS](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fwiki\u002Fjsdom-vs.-PhantomJS)的更完整的比较介绍。\n\n## 获取帮助\n\n如果您需要jsdom的帮助，请随时使用以下任何方式：\n- [邮件组](https:\u002F\u002Fgroups.google.com\u002Fforum\u002F#!forum\u002Fjsdom)(问题最好以\"how do i\"的形式)\n- [报iusse](https:\u002F\u002Fgithub.com\u002Ftmpvar\u002Fjsdom\u002Fissues)(最好用BUG 报告)\n- IRC频道：#jsdom on freenode\n\n## 特别声明\n\n以上文档翻译自开源项目 jsdom，如有翻译错误，欢迎指正。\n\n[jsdom 原文链接](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom\u002Fblob\u002Fmaster\u002FREADME.md)\n\n[jsdom 项目链接](https:\u002F\u002Fgithub.com\u002Fjsdom\u002Fjsdom)\n\n[原文博客地址](https:\u002F\u002Fgithub.com\u002Falibaba-paimai-frontend\u002Fblog\u002Fissues\u002F1)\n\n"
  }
}